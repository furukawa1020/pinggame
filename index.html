<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ğŸ§¶ ã‚ãŸã‚ãŸãƒšãƒ³ã‚®ãƒ³ãƒ‹ãƒƒãƒˆãƒ¯ãƒ¼ãƒ«ãƒ‰ ğŸ§¶</title>
    <link href="https://fonts.googleapis.com/css2?family=Nunito:wght@300;400;600;700;800&display=swap" rel="stylesheet">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            background: radial-gradient(ellipse at center, #F8E6E0, #E8D5C8, #D4C4B0);
            font-family: 'Nunito', sans-serif;
            overflow: hidden;
            user-select: none;
            height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
            position: relative;
        }
        
        /* æ¯›ç³¸ã®èƒŒæ™¯ãƒ†ã‚¯ã‚¹ãƒãƒ£ */
        body::before {
            content: '';
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-image: 
                radial-gradient(circle at 20% 80%, rgba(255,255,255,0.1) 1px, transparent 1px),
                radial-gradient(circle at 80% 20%, rgba(255,255,255,0.1) 1px, transparent 1px),
                radial-gradient(circle at 40% 40%, rgba(255,255,255,0.05) 2px, transparent 2px);
            background-size: 50px 50px, 30px 30px, 70px 70px;
            pointer-events: none;
            z-index: 1;
        }
        
        #gameContainer {
            border: 8px solid;
            border-image: linear-gradient(45deg, #8B4513, #D2691E, #CD853F, #DEB887) 1;
            border-radius: 30px;
            box-shadow: 
                0 0 0 4px #F5DEB3,
                0 20px 60px rgba(0,0,0,0.2),
                inset 0 0 0 2px rgba(255,255,255,0.3);
            background: linear-gradient(135deg, #FFF8DC, #F5F5DC);
            position: relative;
            overflow: hidden;
            z-index: 2;
        }
        
        canvas {
            display: block;
            background: 
                radial-gradient(ellipse at 30% 20%, rgba(255,228,196,0.8), transparent 50%),
                radial-gradient(ellipse at 70% 80%, rgba(255,240,245,0.6), transparent 50%),
                linear-gradient(to bottom, #F0F8FF, #E6F3FF, #DDE9F0);
        }
        
        #ui {
            position: absolute;
            top: 20px;
            left: 20px;
            background: rgba(255,255,255,0.9);
            border: 3px solid #DEB887;
            border-radius: 20px;
            padding: 15px 20px;
            backdrop-filter: blur(10px);
            box-shadow: 0 8px 25px rgba(0,0,0,0.1);
            z-index: 10;
            font-weight: 600;
            color: #8B4513;
        }
        
        .stat-item {
            display: flex;
            align-items: center;
            margin: 8px 0;
            font-size: 16px;
        }
        
        .stat-icon {
            font-size: 20px;
            margin-right: 8px;
            filter: drop-shadow(1px 1px 2px rgba(0,0,0,0.2));
        }
        
        .stat-value {
            font-weight: 800;
            color: #CD853F;
            min-width: 60px;
            text-align: right;
        }
        
        #title {
            position: absolute;
            top: -60px;
            left: 50%;
            transform: translateX(-50%);
            font-size: 32px;
            font-weight: 800;
            background: linear-gradient(45deg, #8B4513, #D2691E, #CD853F);
            background-clip: text;
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            filter: drop-shadow(2px 2px 4px rgba(0,0,0,0.3));
            text-shadow: none;
            z-index: 3;
        }
        
        .control-panel {
            position: absolute;
            bottom: 20px;
            right: 20px;
            display: flex;
            flex-direction: column;
            gap: 12px;
            z-index: 10;
        }
        
        .yarn-button {
            background: linear-gradient(135deg, #FF69B4, #FF1493, #DC143C);
            border: 3px solid #FFF;
            border-radius: 25px;
            padding: 12px 24px;
            color: white;
            font-weight: 700;
            cursor: pointer;
            font-family: 'Nunito', sans-serif;
            font-size: 14px;
            box-shadow: 
                0 6px 20px rgba(255,20,147,0.4),
                inset 0 1px 0 rgba(255,255,255,0.3);
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            position: relative;
            overflow: hidden;
        }
        
        .yarn-button::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255,255,255,0.3), transparent);
            transition: left 0.5s;
        }
        
        .yarn-button:hover {
            transform: translateY(-3px) scale(1.05);
            box-shadow: 
                0 12px 30px rgba(255,20,147,0.6),
                inset 0 1px 0 rgba(255,255,255,0.4);
        }
        
        .yarn-button:hover::before {
            left: 100%;
        }
        
        .yarn-button:active {
            transform: translateY(-1px) scale(1.02);
        }
        
        .special-button {
            background: linear-gradient(135deg, #FFD700, #FFA500, #FF8C00);
            box-shadow: 
                0 6px 20px rgba(255,215,0,0.4),
                inset 0 1px 0 rgba(255,255,255,0.3);
        }
        
        .special-button:hover {
            box-shadow: 
                0 12px 30px rgba(255,215,0,0.6),
                inset 0 1px 0 rgba(255,255,255,0.4);
        }
        
        .mood-indicator {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(255,255,255,0.9);
            border: 3px solid #DEB887;
            border-radius: 20px;
            padding: 12px 16px;
            backdrop-filter: blur(10px);
            box-shadow: 0 8px 25px rgba(0,0,0,0.1);
            z-index: 10;
        }
        
        .mood-bar {
            width: 120px;
            height: 8px;
            background: #E0E0E0;
            border-radius: 4px;
            overflow: hidden;
            margin-top: 5px;
        }
        
        .mood-fill {
            height: 100%;
            background: linear-gradient(90deg, #FF69B4, #FFB6C1, #FFC0CB);
            border-radius: 4px;
            transition: width 0.3s ease;
        }
        
        .settings-panel {
            position: absolute;
            bottom: 20px;
            left: 20px;
            display: flex;
            gap: 10px;
            z-index: 10;
        }
        
        .mini-button {
            width: 50px;
            height: 50px;
            border-radius: 50%;
            border: 3px solid #FFF;
            background: linear-gradient(135deg, #87CEEB, #4169E1);
            color: white;
            font-size: 20px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: 0 4px 12px rgba(0,0,0,0.2);
            transition: all 0.3s ease;
        }
        
        .mini-button:hover {
            transform: translateY(-2px) scale(1.1);
            box-shadow: 0 6px 18px rgba(0,0,0,0.3);
        }
        
        @keyframes yarnFloat {
            0%, 100% { transform: translateY(0px) rotate(0deg); }
            33% { transform: translateY(-10px) rotate(120deg); }
            66% { transform: translateY(-5px) rotate(240deg); }
        }
        
        .floating-yarn {
            position: absolute;
            font-size: 24px;
            animation: yarnFloat 4s ease-in-out infinite;
            pointer-events: none;
            z-index: 5;
        }
        
        /* ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹æœ€é©åŒ– */
        canvas {
            image-rendering: optimizeSpeed;
            image-rendering: -moz-crisp-edges;
            image-rendering: -webkit-optimize-contrast;
            image-rendering: optimize-contrast;
        }
    </style>
</head>
<body>
    <div id="gameContainer">
        <div id="title">ğŸ§¶ ã‚ãŸã‚ãŸãƒšãƒ³ã‚®ãƒ³ãƒ‹ãƒƒãƒˆãƒ¯ãƒ¼ãƒ«ãƒ‰ ğŸ§¶</div>
        
        <div id="ui">
            <div class="stat-item">
                <span class="stat-icon">ğŸŸ</span>
                <span>ã•ã‹ãª: </span>
                <span class="stat-value" id="fishCount">0</span>
            </div>
            <div class="stat-item">
                <span class="stat-icon">â­</span>
                <span>ã‚¹ã‚³ã‚¢: </span>
                <span class="stat-value" id="score">0</span>
            </div>
            <div class="stat-item">
                <span class="stat-icon">ğŸ§</span>
                <span>ãƒšãƒ³ã‚®ãƒ³: </span>
                <span class="stat-value" id="penguinCount">3</span>
            </div>
            <div class="stat-item">
                <span class="stat-icon">ğŸ§¶</span>
                <span>æ¯›ç³¸ç‰: </span>
                <span class="stat-value" id="yarnCount">0</span>
            </div>
        </div>
        
        <div class="mood-indicator">
            <div style="font-weight: 600; color: #8B4513; font-size: 14px;">ğŸŒŸ ãƒ•ã‚¡ã‚¯ãƒˆãƒªãƒ¼ãƒ ãƒ¼ãƒ‰</div>
            <div class="mood-bar">
                <div class="mood-fill" id="moodFill" style="width: 70%"></div>
            </div>
        </div>
        
        <canvas id="gameCanvas" width="900" height="700"></canvas>
        
        <div class="control-panel">
            <button class="yarn-button" onclick="addPenguin()">
                ğŸ§ ãƒšãƒ³ã‚®ãƒ³è¿½åŠ  (ã‚³ã‚¹ãƒˆ: 10ğŸŸ)
            </button>
            <button class="yarn-button" onclick="upgradeFactory()">
                âš¡ å·¥å ´ã‚¢ãƒƒãƒ—ã‚°ãƒ¬ãƒ¼ãƒ‰ (ã‚³ã‚¹ãƒˆ: 50ğŸŸ)
            </button>
            <button class="yarn-button special-button" onclick="activateTurboMode()">
                ğŸš€ ã‚¿ãƒ¼ãƒœãƒ¢ãƒ¼ãƒ‰ (ã‚³ã‚¹ãƒˆ: 100ğŸŸ)
            </button>
            <button class="yarn-button" onclick="buyDecoration()">
                ğŸ¨ ãƒ‡ã‚³ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³ (ã‚³ã‚¹ãƒˆ: 25ğŸŸ)
            </button>
        </div>
        
        <div class="settings-panel">
            <button class="mini-button" onclick="toggleSound()" title="éŸ³éŸ¿åŠ¹æœ">ğŸ”Š</button>
            <button class="mini-button" onclick="saveGame()" title="ã‚²ãƒ¼ãƒ ä¿å­˜">ğŸ’¾</button>
            <button class="mini-button" onclick="showStats()" title="çµ±è¨ˆæƒ…å ±">ğŸ“Š</button>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        
        // ã‚²ãƒ¼ãƒ çŠ¶æ…‹ç®¡ç†
        let gameState = {
            fish: 0,
            score: 0,
            yarnBalls: 0,
            factoryLevel: 1,
            mood: 70,
            turboMode: false,
            turboTimer: 0,
            penguins: [],
            fishItems: [],
            yarnItems: [],
            particles: [],
            decorations: [],
            time: 0,
            soundEnabled: true,
            savedAt: Date.now()
        };
        
        // æœ€æ–°å¼ãƒ‹ãƒ¥ãƒ¼ãƒ©ãƒ«ãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯ã‚¯ãƒ©ã‚¹ï¼ˆè»½é‡ç‰ˆï¼‰
        class MiniNeuralNetwork {
            constructor(inputSize, hiddenSize, outputSize) {
                this.inputSize = inputSize;
                this.hiddenSize = hiddenSize;
                this.outputSize = outputSize;
                
                // é‡ã¿åˆæœŸåŒ–ï¼ˆXavieråˆæœŸåŒ–ï¼‰
                this.weightsIH = this.initializeWeights(inputSize, hiddenSize);
                this.weightsHO = this.initializeWeights(hiddenSize, outputSize);
                this.biasH = new Array(hiddenSize).fill(0).map(() => (Math.random() - 0.5) * 0.1);
                this.biasO = new Array(outputSize).fill(0).map(() => (Math.random() - 0.5) * 0.1);
                
                // å­¦ç¿’ç‡
                this.learningRate = 0.01;
            }
            
            initializeWeights(rows, cols) {
                const weights = [];
                const limit = Math.sqrt(6 / (rows + cols));
                for (let i = 0; i < rows; i++) {
                    weights[i] = [];
                    for (let j = 0; j < cols; j++) {
                        weights[i][j] = (Math.random() - 0.5) * 2 * limit;
                    }
                }
                return weights;
            }
            
            sigmoid(x) {
                return 1 / (1 + Math.exp(-Math.max(-500, Math.min(500, x))));
            }
            
            tanh(x) {
                return Math.tanh(Math.max(-500, Math.min(500, x)));
            }
            
            forward(inputs) {
                // éš ã‚Œå±¤ã®è¨ˆç®—
                const hidden = [];
                for (let i = 0; i < this.hiddenSize; i++) {
                    let sum = this.biasH[i];
                    for (let j = 0; j < this.inputSize; j++) {
                        sum += inputs[j] * this.weightsIH[j][i];
                    }
                    hidden[i] = this.tanh(sum);
                }
                
                // å‡ºåŠ›å±¤ã®è¨ˆç®—
                const outputs = [];
                for (let i = 0; i < this.outputSize; i++) {
                    let sum = this.biasO[i];
                    for (let j = 0; j < this.hiddenSize; j++) {
                        sum += hidden[j] * this.weightsHO[j][i];
                    }
                    outputs[i] = this.sigmoid(sum);
                }
                
                return { hidden, outputs };
            }
            
            // å¼·åŒ–å­¦ç¿’çš„ãªé‡ã¿æ›´æ–°
            updateWeights(inputs, reward, action) {
                const { hidden, outputs } = this.forward(inputs);
                
                // ç°¡å˜ãªé‡ã¿æ›´æ–°ï¼ˆæ–¹ç­–å‹¾é…çš„ï¼‰
                const delta = reward * this.learningRate;
                
                // å‡ºåŠ›å±¤ã®æ›´æ–°
                for (let i = 0; i < this.outputSize; i++) {
                    this.biasO[i] += delta * (i === action ? 1 : -0.1);
                    for (let j = 0; j < this.hiddenSize; j++) {
                        this.weightsHO[j][i] += delta * hidden[j] * (i === action ? 1 : -0.1);
                    }
                }
                
                // éš ã‚Œå±¤ã®æ›´æ–°
                for (let i = 0; i < this.hiddenSize; i++) {
                    this.biasH[i] += delta * 0.1;
                    for (let j = 0; j < this.inputSize; j++) {
                        this.weightsIH[j][i] += delta * inputs[j] * 0.1;
                    }
                }
            }
        }
        
        // é€²åŒ–ã—ãŸãƒšãƒ³ã‚®ãƒ³ã‚¯ãƒ©ã‚¹ï¼ˆãƒ‹ãƒ¥ãƒ¼ãƒ©ãƒ«ãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯æ­è¼‰ï¼‰
        class IntelligentPenguin {
            constructor(x, y) {
                this.x = x;
                this.y = y;
                this.targetX = x;
                this.targetY = y;
                this.baseSpeed = 0.8 + Math.random() * 0.7;
                this.size = 30 + Math.random() * 15;
                this.color = this.generateYarnColor();
                this.state = 'idle';
                this.workTimer = 0;
                this.happiness = 50 + Math.random() * 50;
                this.energy = 100;
                this.intelligence = 0.5 + Math.random() * 0.5;
                this.personality = Math.random();
                this.direction = Math.random() > 0.5 ? 1 : -1;
                this.lastAction = 0;
                this.yarnTexture = this.generateYarnTexture();
                
                // ãƒ‹ãƒ¥ãƒ¼ãƒ©ãƒ«ãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯åˆæœŸåŒ–
                this.brain = new MiniNeuralNetwork(8, 12, 4); // 8å…¥åŠ›, 12éš ã‚Œ, 4å‡ºåŠ›
                this.memory = [];
                this.lastReward = 0;
                this.actionHistory = [];
                
                // ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ç”¨
                this.wobbleOffset = Math.random() * Math.PI * 2;
                this.blinkTimer = Math.random() * 200;
                this.isBlinking = false;
                
                // æ¯›ç³¸é¢¨ãƒ†ã‚¯ã‚¹ãƒãƒ£
                this.stitchPattern = this.generateStitchPattern();
            }
            
            generateYarnColor() {
                const yarnColors = [
                    '#E6B3BA', '#F4D3AE', '#B8E6B8', '#A8D8EA',
                    '#FFD93D', '#FF9FF3', '#A8DADC', '#F1C0E8'
                ];
                return yarnColors[Math.floor(Math.random() * yarnColors.length)];
            }
            
            generateYarnTexture() {
                return {
                    roughness: Math.random() * 0.3 + 0.1,
                    shine: Math.random() * 0.5 + 0.2,
                    pattern: Math.floor(Math.random() * 3)
                };
            }
            
            generateStitchPattern() {
                const patterns = [];
                for (let i = 0; i < 8; i++) {
                    patterns.push({
                        x: (Math.random() - 0.5) * this.size * 0.8,
                        y: (Math.random() - 0.5) * this.size * 0.8,
                        size: 2 + Math.random() * 3
                    });
                }
                return patterns;
            }
            
            // é«˜åº¦ãªAIæ€è€ƒãƒ—ãƒ­ã‚»ã‚¹
            think() {
                // ç’°å¢ƒèªè­˜ï¼ˆ8æ¬¡å…ƒå…¥åŠ›ãƒ™ã‚¯ãƒˆãƒ«ï¼‰
                const inputs = this.perceiveEnvironment();
                
                // ãƒ‹ãƒ¥ãƒ¼ãƒ©ãƒ«ãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯ã§è¡Œå‹•æ±ºå®š
                const { outputs } = this.brain.forward(inputs);
                
                // è¡Œå‹•é¸æŠï¼ˆÎµ-ã‚°ãƒªãƒ¼ãƒ‡ã‚£æ³•ï¼‰
                let action;
                if (Math.random() < 0.1) { // 10%ã®ç¢ºç‡ã§ãƒ©ãƒ³ãƒ€ãƒ æ¢ç´¢
                    action = Math.floor(Math.random() * 4);
                } else {
                    action = outputs.indexOf(Math.max(...outputs));
                }
                
                // è¡Œå‹•å®Ÿè¡Œ
                this.executeAction(action);
                
                // å ±é…¬è¨ˆç®—ã¨å­¦ç¿’
                const reward = this.calculateReward();
                if (this.actionHistory.length > 0) {
                    const lastInput = this.actionHistory[this.actionHistory.length - 1].input;
                    const lastAction = this.actionHistory[this.actionHistory.length - 1].action;
                    this.brain.updateWeights(lastInput, reward, lastAction);
                }
                
                // å±¥æ­´ä¿å­˜
                this.actionHistory.push({ input: inputs, action, reward });
                if (this.actionHistory.length > 10) {
                    this.actionHistory.shift();
                }
                
                // åŸºæœ¬çš„ãªç”Ÿç†çŠ¶æ…‹æ›´æ–°
                this.energy -= 0.1;
                if (this.energy < 0) this.energy = 0;
                if (this.energy < 20) this.happiness -= 0.5;
                
                // ã¾ã°ãŸãåˆ¶å¾¡
                this.blinkTimer++;
                if (this.blinkTimer > 180 + Math.random() * 120) {
                    this.isBlinking = true;
                    setTimeout(() => this.isBlinking = false, 150);
                    this.blinkTimer = 0;
                }
            }
            
            perceiveEnvironment() {
                const nearestFish = this.findNearestFish();
                const nearestPenguin = this.findNearestPenguin();
                const nearestYarn = this.findNearestYarn();
                
                return [
                    this.x / canvas.width,                                    // è‡ªåˆ†ã®Xä½ç½®ï¼ˆæ­£è¦åŒ–ï¼‰
                    this.y / canvas.height,                                   // è‡ªåˆ†ã®Yä½ç½®ï¼ˆæ­£è¦åŒ–ï¼‰
                    this.happiness / 100,                                     // å¹¸ç¦åº¦
                    this.energy / 100,                                        // ã‚¨ãƒãƒ«ã‚®ãƒ¼
                    nearestFish ? this.distanceTo(nearestFish.x, nearestFish.y) / 500 : 1, // æœ€è¿‘å‚é­šã¸ã®è·é›¢
                    nearestPenguin ? this.distanceTo(nearestPenguin.x, nearestPenguin.y) / 500 : 1, // æœ€è¿‘å‚ãƒšãƒ³ã‚®ãƒ³ã¸ã®è·é›¢
                    nearestYarn ? this.distanceTo(nearestYarn.x, nearestYarn.y) / 500 : 1, // æœ€è¿‘å‚æ¯›ç³¸ã¸ã®è·é›¢
                    gameState.mood / 100                                      // å…¨ä½“ãƒ ãƒ¼ãƒ‰
                ];
            }
            
            executeAction(action) {
                switch (action) {
                    case 0: // é­šã‚’æ¢ã—ã«è¡Œã
                        this.goToNearestFish();
                        break;
                    case 1: // æ¯›ç³¸ç‰ã‚’æ¢ã—ã«è¡Œã
                        this.goToNearestYarn();
                        break;
                    case 2: // ä»–ã®ãƒšãƒ³ã‚®ãƒ³ã¨ç¤¾äº¤
                        this.socializeWithNearestPenguin();
                        break;
                    case 3: // ä¼‘æ†©
                        this.rest();
                        break;
                }
            }
            
            calculateReward() {
                let reward = 0;
                
                // åŸºæœ¬ç”Ÿå­˜å ±é…¬
                reward += 0.1;
                
                // å¹¸ç¦åº¦ã«åŸºã¥ãå ±é…¬
                reward += (this.happiness - 50) / 100;
                
                // é­šåé›†å ±é…¬
                if (this.state === 'working' && this.workTimer > 0) {
                    reward += 0.5;
                }
                
                // ã‚¨ãƒãƒ«ã‚®ãƒ¼ç®¡ç†å ±é…¬
                if (this.energy > 80) reward += 0.2;
                if (this.energy < 20) reward -= 0.3;
                
                // ç¤¾äº¤å ±é…¬
                const nearbyPenguins = this.countNearbyPenguins();
                if (nearbyPenguins > 0 && nearbyPenguins < 3) {
                    reward += 0.3;
                }
                
                return reward;
            }
            
            findNearestFish() {
                if (gameState.fishItems.length === 0) return null;
                let nearest = gameState.fishItems[0];
                let minDist = this.distanceTo(nearest.x, nearest.y);
                
                for (let fish of gameState.fishItems) {
                    let dist = this.distanceTo(fish.x, fish.y);
                    if (dist < minDist) {
                        minDist = dist;
                        nearest = fish;
                    }
                }
                return nearest;
            }
            
            findNearestPenguin() {
                let nearest = null;
                let minDist = Infinity;
                
                for (let penguin of gameState.penguins) {
                    if (penguin === this) continue;
                    let dist = this.distanceTo(penguin.x, penguin.y);
                    if (dist < minDist) {
                        minDist = dist;
                        nearest = penguin;
                    }
                }
                return nearest;
            }
            
            findNearestYarn() {
                if (gameState.yarnItems.length === 0) return null;
                let nearest = gameState.yarnItems[0];
                let minDist = this.distanceTo(nearest.x, nearest.y);
                
                for (let yarn of gameState.yarnItems) {
                    let dist = this.distanceTo(yarn.x, yarn.y);
                    if (dist < minDist) {
                        minDist = dist;
                        nearest = yarn;
                    }
                }
                return nearest;
            }
            
            countNearbyPenguins() {
                let count = 0;
                for (let penguin of gameState.penguins) {
                    if (penguin !== this && this.distanceTo(penguin.x, penguin.y) < 100) {
                        count++;
                    }
                }
                return count;
            }
            
            goToNearestFish() {
                const fish = this.findNearestFish();
                if (fish) {
                    this.targetX = fish.x;
                    this.targetY = fish.y;
                    this.state = 'moving';
                }
            }
            
            goToNearestYarn() {
                const yarn = this.findNearestYarn();
                if (yarn) {
                    this.targetX = yarn.x;
                    this.targetY = yarn.y;
                    this.state = 'moving';
                }
            }
            
            socializeWithNearestPenguin() {
                const penguin = this.findNearestPenguin();
                if (penguin) {
                    this.targetX = penguin.x + (Math.random() - 0.5) * 100;
                    this.targetY = penguin.y + (Math.random() - 0.5) * 100;
                    this.state = 'moving';
                    this.happiness += 5;
                }
            }
            
            rest() {
                this.state = 'idle';
                this.energy += 2;
                if (this.energy > 100) this.energy = 100;
            }
            
            distanceTo(x, y) {
                return Math.sqrt((this.x - x) ** 2 + (this.y - y) ** 2);
            }
            
            reachedTarget() {
                return this.distanceTo(this.targetX, this.targetY) < 8;
            }
            
            collectNearbyItems() {
                // é­šåé›†
                for (let i = gameState.fishItems.length - 1; i >= 0; i--) {
                    let fish = gameState.fishItems[i];
                    if (this.distanceTo(fish.x, fish.y) < 50) {
                        gameState.fishItems.splice(i, 1);
                        gameState.fish++;
                        gameState.score += 15;
                        this.happiness += 15;
                        this.energy += 10;
                        this.createYarnParticles();
                        break;
                    }
                }
                
                // æ¯›ç³¸ç‰åé›†
                for (let i = gameState.yarnItems.length - 1; i >= 0; i--) {
                    let yarn = gameState.yarnItems[i];
                    if (this.distanceTo(yarn.x, yarn.y) < 50) {
                        gameState.yarnItems.splice(i, 1);
                        gameState.yarnBalls++;
                        gameState.score += 25;
                        this.happiness += 20;
                        this.createSpecialParticles();
                        break;
                    }
                }
            }
            
            createYarnParticles() {
                for (let i = 0; i < 12; i++) {
                    gameState.particles.push({
                        x: this.x,
                        y: this.y - 15,
                        vx: (Math.random() - 0.5) * 6,
                        vy: -Math.random() * 4 - 2,
                        life: 80,
                        maxLife: 80,
                        color: `hsl(${Math.random() * 60 + 320}, 75%, 75%)`,
                        size: 3 + Math.random() * 4,
                        type: 'yarn'
                    });
                }
            }
            
            createSpecialParticles() {
                for (let i = 0; i < 16; i++) {
                    gameState.particles.push({
                        x: this.x,
                        y: this.y - 20,
                        vx: (Math.random() - 0.5) * 8,
                        vy: -Math.random() * 6 - 3,
                        life: 120,
                        maxLife: 120,
                        color: `hsl(${Math.random() * 360}, 80%, 70%)`,
                        size: 4 + Math.random() * 6,
                        type: 'special'
                    });
                }
            }
            
            update() {
                this.think();
                
                // ã‚¹ãƒ ãƒ¼ã‚ºãªç§»å‹•ï¼ˆã‚¤ãƒ¼ã‚¸ãƒ³ã‚°ï¼‰
                if (this.state === 'moving') {
                    let dx = this.targetX - this.x;
                    let dy = this.targetY - this.y;
                    let speed = this.baseSpeed * (gameState.turboMode ? 2 : 1);
                    
                    this.x += dx * speed * 0.08;
                    this.y += dy * speed * 0.08;
                    
                    this.direction = dx > 0 ? 1 : -1;
                    
                    if (this.reachedTarget()) {
                        this.state = 'working';
                        this.workTimer = 40 + Math.random() * 80;
                    }
                } else if (this.state === 'working') {
                    this.workTimer--;
                    if (this.workTimer <= 0) {
                        this.state = 'idle';
                        this.collectNearbyItems();
                    }
                }
                
                // å¢ƒç•Œãƒã‚§ãƒƒã‚¯ï¼ˆã‚½ãƒ•ãƒˆãƒã‚¦ãƒ³ã‚¹ï¼‰
                const margin = this.size;
                if (this.x < margin) {
                    this.x = margin;
                    this.targetX = margin + 50;
                }
                if (this.x > canvas.width - margin) {
                    this.x = canvas.width - margin;
                    this.targetX = canvas.width - margin - 50;
                }
                if (this.y < margin) {
                    this.y = margin;
                    this.targetY = margin + 50;
                }
                if (this.y > canvas.height - margin) {
                    this.y = canvas.height - margin;
                    this.targetY = canvas.height - margin - 50;
                }
                
                // å¹¸ç¦åº¦ã®è‡ªç„¶å¤‰åŒ–
                this.happiness += (Math.random() - 0.5) * 0.3;
                this.happiness = Math.max(0, Math.min(100, this.happiness));
            }
            
            drawYarnTexture() {
                // ãƒšãƒ³ã‚®ãƒ³ã®ä½“ï¼ˆæ¯›ç³¸é¢¨ï¼‰
                ctx.save();
                
                // ä½“ã®åŸºæœ¬å½¢ï¼ˆãƒšãƒ³ã‚®ãƒ³ã‚‰ã—ã„æ¥•å††ï¼‰
                ctx.fillStyle = '#2C3E50'; // ãƒšãƒ³ã‚®ãƒ³ã®é»’ã„éƒ¨åˆ†
                ctx.beginPath();
                ctx.ellipse(0, 5, this.size * 0.8, this.size * 1.1, 0, 0, Math.PI * 2);
                ctx.fill();
                
                // ãŠè…¹ã®ç™½ã„éƒ¨åˆ†
                ctx.fillStyle = '#FFFEF7';
                ctx.beginPath();
                ctx.ellipse(0, 8, this.size * 0.55, this.size * 0.9, 0, 0, Math.PI * 2);
                ctx.fill();
                
                // æ¯›ç³¸ã®ç¸«ã„ç›®ãƒ‘ã‚¿ãƒ¼ãƒ³ï¼ˆä½“ã«ï¼‰
                ctx.strokeStyle = 'rgba(139, 69, 19, 0.3)';
                ctx.lineWidth = 1;
                ctx.lineCap = 'round';
                
                for (let stitch of this.stitchPattern) {
                    ctx.beginPath();
                    ctx.moveTo(stitch.x - stitch.size * 0.5, stitch.y);
                    ctx.lineTo(stitch.x + stitch.size * 0.5, stitch.y);
                    ctx.stroke();
                }
                
                // ãƒšãƒ³ã‚®ãƒ³ã®é ­
                ctx.fillStyle = '#2C3E50';
                ctx.beginPath();
                ctx.ellipse(0, -this.size * 0.6, this.size * 0.7, this.size * 0.6, 0, 0, Math.PI * 2);
                ctx.fill();
                
                ctx.restore();
            }
            
            adjustBrightness(color, amount) {
                // è‰²ã®æ˜åº¦ã‚’èª¿æ•´
                const num = parseInt(color.replace("#",""), 16);
                const amt = Math.round(2.55 * amount * 100);
                const R = (num >> 16) + amt;
                const G = (num >> 8 & 0x00FF) + amt;
                const B = (num & 0x0000FF) + amt;
                return "#" + (0x1000000 + (R < 255 ? R < 1 ? 0 : R : 255) * 0x10000 +
                    (G < 255 ? G < 1 ? 0 : G : 255) * 0x100 +
                    (B < 255 ? B < 1 ? 0 : B : 255)).toString(16).slice(1);
            }
            
            draw() {
                ctx.save();
                ctx.translate(this.x, this.y);
                ctx.scale(this.direction, 1);
                
                // ã½ã‚ˆã½ã‚ˆã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ï¼ˆã‚ˆã‚ŠæŸ”ã‚‰ã‹ãï¼‰
                let wobble = Math.sin((gameState.time + this.wobbleOffset) * 0.08) * 2;
                let stretch = 1 + Math.sin((gameState.time + this.wobbleOffset) * 0.12) * 0.03;
                ctx.translate(0, wobble);
                ctx.scale(stretch, 1/stretch);
                
                // ã‚½ãƒ•ãƒˆã‚·ãƒ£ãƒ‰ã‚¦
                ctx.fillStyle = 'rgba(139, 69, 19, 0.2)';
                ctx.beginPath();
                ctx.ellipse(2, this.size + 8, this.size * 0.9, this.size * 0.4, 0, 0, Math.PI * 2);
                ctx.fill();
                
                // ãƒšãƒ³ã‚®ãƒ³ã®ä½“ï¼ˆæ¯›ç³¸ãƒ†ã‚¯ã‚¹ãƒãƒ£ï¼‰
                this.drawYarnTexture();
                
                // ãƒšãƒ³ã‚®ãƒ³ã®ç¿¼
                ctx.fillStyle = '#2C3E50';
                ctx.beginPath();
                ctx.ellipse(-this.size * 0.6, 0, this.size * 0.25, this.size * 0.7, -0.3, 0, Math.PI * 2);
                ctx.fill();
                ctx.beginPath();
                ctx.ellipse(this.size * 0.6, 0, this.size * 0.25, this.size * 0.7, 0.3, 0, Math.PI * 2);
                ctx.fill();
                
                // ãƒšãƒ³ã‚®ãƒ³ã®è¶³
                ctx.fillStyle = '#FFB347';
                ctx.beginPath();
                ctx.ellipse(-this.size * 0.2, this.size + 5, 8, 12, 0, 0, Math.PI * 2);
                ctx.fill();
                ctx.beginPath();
                ctx.ellipse(this.size * 0.2, this.size + 5, 8, 12, 0, 0, Math.PI * 2);
                ctx.fill();
                
                // ãƒšãƒ³ã‚®ãƒ³ã®ãã¡ã°ã—
                ctx.fillStyle = '#FFB347';
                ctx.beginPath();
                ctx.moveTo(-this.size * 0.45, -this.size * 0.6);
                ctx.lineTo(-this.size * 0.65, -this.size * 0.55);
                ctx.lineTo(-this.size * 0.45, -this.size * 0.5);
                ctx.closePath();
                ctx.fill();
                
                // ãƒšãƒ³ã‚®ãƒ³ã®ç›®ï¼ˆã¾ã°ãŸãå¯¾å¿œï¼‰
                if (!this.isBlinking) {
                    // ç™½ç›®
                    ctx.fillStyle = '#FFFFFF';
                    ctx.beginPath();
                    ctx.ellipse(-this.size * 0.25, -this.size * 0.7, 8, 10, 0, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.beginPath();
                    ctx.ellipse(this.size * 0.25, -this.size * 0.7, 8, 10, 0, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // ç³
                    ctx.fillStyle = '#2C3E50';
                    ctx.beginPath();
                    ctx.ellipse(-this.size * 0.25, -this.size * 0.7, 4, 6, 0, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.beginPath();
                    ctx.ellipse(this.size * 0.25, -this.size * 0.7, 4, 6, 0, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // ãƒã‚¤ãƒ©ã‚¤ãƒˆ
                    ctx.fillStyle = '#FFFFFF';
                    ctx.beginPath();
                    ctx.ellipse(-this.size * 0.25 + 2, -this.size * 0.7 - 2, 2, 3, 0, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.beginPath();
                    ctx.ellipse(this.size * 0.25 + 2, -this.size * 0.7 - 2, 2, 3, 0, 0, Math.PI * 2);
                    ctx.fill();
                } else {
                    // ã¾ã°ãŸã
                    ctx.strokeStyle = '#2C3E50';
                    ctx.lineWidth = 3;
                    ctx.lineCap = 'round';
                    ctx.beginPath();
                    ctx.moveTo(-this.size * 0.33, -this.size * 0.7);
                    ctx.lineTo(-this.size * 0.17, -this.size * 0.7);
                    ctx.stroke();
                    ctx.beginPath();
                    ctx.moveTo(this.size * 0.17, -this.size * 0.7);
                    ctx.lineTo(this.size * 0.33, -this.size * 0.7);
                    ctx.stroke();
                }
                
                // å¹¸ã›åº¦ã«ã‚ˆã‚‹è¡¨æƒ…å¤‰åŒ–
                if (this.happiness > 80) {
                    ctx.strokeStyle = '#FF69B4';
                    ctx.lineWidth = 2;
                    ctx.lineCap = 'round';
                    ctx.beginPath();
                    ctx.arc(0, -this.size * 0.45, 12, 0.2, Math.PI - 0.2);
                    ctx.stroke();
                } else if (this.happiness < 30) {
                    ctx.strokeStyle = '#4169E1';
                    ctx.lineWidth = 2;
                    ctx.lineCap = 'round';
                    ctx.beginPath();
                    ctx.arc(0, -this.size * 0.4, 10, Math.PI + 0.2, 2 * Math.PI - 0.2);
                    ctx.stroke();
                }
                
                // ã‚¨ãƒãƒ«ã‚®ãƒ¼çŠ¶æ…‹ã®è¡¨ç¤º
                if (this.energy < 30) {
                    ctx.fillStyle = 'rgba(255, 255, 0, 0.7)';
                    ctx.font = '14px Nunito';
                    ctx.textAlign = 'center';
                    ctx.fillText('ğŸ’¤', 0, -this.size - 20);
                }
                
                // ä½œæ¥­ä¸­ã‚¨ãƒ•ã‚§ã‚¯ãƒˆ
                if (this.state === 'working') {
                    const sparkles = ['âœ¨', 'â­', 'ğŸ’«', 'ğŸŒŸ'];
                    ctx.fillStyle = '#FFD700';
                    ctx.font = '16px Nunito';
                    ctx.textAlign = 'center';
                    ctx.fillText(sparkles[Math.floor(gameState.time / 20) % sparkles.length], 0, -this.size - 25);
                }
                
                // æ¯›ç³¸ã®è³ªæ„Ÿã‚¨ãƒ•ã‚§ã‚¯ãƒˆ
                if (Math.random() < 0.1) {
                    ctx.strokeStyle = 'rgba(255, 255, 255, 0.5)';
                    ctx.lineWidth = 1;
                    ctx.globalAlpha = 0.4;
                    for (let i = 0; i < 2; i++) {
                        ctx.beginPath();
                        ctx.moveTo((Math.random() - 0.5) * this.size, (Math.random() - 0.5) * this.size);
                        ctx.lineTo((Math.random() - 0.5) * this.size, (Math.random() - 0.5) * this.size);
                        ctx.stroke();
                    }
                    ctx.globalAlpha = 1;
                }
                
                ctx.restore();
            }
        }
        
        // é«˜å“è³ªé­šã‚¢ã‚¤ãƒ†ãƒ ã‚¯ãƒ©ã‚¹
        class YarnFish {
            constructor(x, y) {
                this.x = x;
                this.y = y;
                this.size = 18 + Math.random() * 8;
                this.bobOffset = Math.random() * Math.PI * 2;
                this.sparkleTimer = Math.random() * 100;
                this.color = this.generateFishColor();
                this.yarnTexture = this.generateYarnTexture();
                this.swimDirection = Math.random() * Math.PI * 2;
                this.swimSpeed = 0.3 + Math.random() * 0.5;
                this.glowIntensity = 0.5 + Math.random() * 0.5;
            }
            
            generateFishColor() {
                const fishColors = [
                    '#FFB6C1', '#FFA07A', '#F0E68C', '#98FB98',
                    '#87CEEB', '#DDA0DD', '#F5DEB3', '#FFE4E1'
                ];
                return fishColors[Math.floor(Math.random() * fishColors.length)];
            }
            
            generateYarnTexture() {
                return {
                    pattern: Math.floor(Math.random() * 4),
                    density: 0.3 + Math.random() * 0.4,
                    shine: Math.random() * 0.7 + 0.3
                };
            }
            
            update() {
                // è‡ªç„¶ãªæ³³ã
                this.x += Math.cos(this.swimDirection) * this.swimSpeed;
                this.y += Math.sin(this.swimDirection) * this.swimSpeed * 0.5;
                
                // æ–¹å‘è»¢æ›
                if (Math.random() < 0.02) {
                    this.swimDirection += (Math.random() - 0.5) * 0.5;
                }
                
                // å¢ƒç•Œã§ãƒã‚¦ãƒ³ã‚¹
                if (this.x < this.size || this.x > canvas.width - this.size) {
                    this.swimDirection = Math.PI - this.swimDirection;
                }
                if (this.y < this.size || this.y > canvas.height - this.size) {
                    this.swimDirection = -this.swimDirection;
                }
                
                // å¢ƒç•Œå†…ã«ä¿æŒ
                this.x = Math.max(this.size, Math.min(canvas.width - this.size, this.x));
                this.y = Math.max(this.size, Math.min(canvas.height - this.size, this.y));
                
                this.sparkleTimer++;
                if (this.sparkleTimer > 80) {
                    this.sparkleTimer = 0;
                    this.createSparkle();
                }
            }
            
            createSparkle() {
                gameState.particles.push({
                    x: this.x + (Math.random() - 0.5) * 25,
                    y: this.y + (Math.random() - 0.5) * 25,
                    vx: (Math.random() - 0.5) * 2,
                    vy: -0.5 - Math.random() * 1,
                    life: 60,
                    maxLife: 60,
                    color: '#87CEEB',
                    size: 2 + Math.random() * 3,
                    type: 'sparkle'
                });
            }
            
            draw() {
                ctx.save();
                ctx.translate(this.x, this.y + Math.sin((gameState.time + this.bobOffset) * 0.08) * 4);
                
                // ã‚°ãƒ­ãƒ¼åŠ¹æœ
                ctx.shadowColor = this.color;
                ctx.shadowBlur = 8 * this.glowIntensity;
                
                // é­šã®å½±
                ctx.shadowColor = 'rgba(139, 69, 19, 0.3)';
                ctx.shadowBlur = 4;
                ctx.fillStyle = 'rgba(139, 69, 19, 0.2)';
                ctx.beginPath();
                ctx.ellipse(2, 12, this.size * 0.8, this.size * 0.4, 0, 0, Math.PI * 2);
                ctx.fill();
                
                ctx.shadowBlur = 0;
                
                // é­šæœ¬ä½“ï¼ˆæ¯›ç³¸é¢¨ï¼‰
                ctx.fillStyle = this.color;
                ctx.beginPath();
                ctx.ellipse(0, 0, this.size, this.size * 0.75, 0, 0, Math.PI * 2);
                ctx.fill();
                
                // æ¯›ç³¸ã®ç¸«ã„ç›®
                ctx.strokeStyle = this.adjustBrightness(this.color, -0.3);
                ctx.lineWidth = 1;
                ctx.lineCap = 'round';
                for (let i = 0; i < 4; i++) {
                    ctx.beginPath();
                    ctx.moveTo(-this.size * 0.6 + i * (this.size * 0.3), -2);
                    ctx.lineTo(-this.size * 0.6 + i * (this.size * 0.3), 2);
                    ctx.stroke();
                }
                
                // å°»å°¾ï¼ˆæ¯›ç³¸é¢¨ï¼‰
                ctx.fillStyle = this.adjustBrightness(this.color, -0.1);
                ctx.beginPath();
                ctx.moveTo(this.size, 0);
                ctx.lineTo(this.size + 12, -8);
                ctx.lineTo(this.size + 12, 8);
                ctx.closePath();
                ctx.fill();
                
                // ç›®
                ctx.fillStyle = '#FFFFFF';
                ctx.beginPath();
                ctx.arc(-this.size * 0.4, -4, 4, 0, Math.PI * 2);
                ctx.fill();
                
                ctx.fillStyle = '#2C3E50';
                ctx.beginPath();
                ctx.arc(-this.size * 0.4, -4, 2, 0, Math.PI * 2);
                ctx.fill();
                
                // ãƒã‚¤ãƒ©ã‚¤ãƒˆ
                ctx.fillStyle = this.adjustBrightness(this.color, 0.4);
                ctx.globalAlpha = 0.7;
                ctx.beginPath();
                ctx.ellipse(-this.size * 0.3, -this.size * 0.2, this.size * 0.3, this.size * 0.2, 0, 0, Math.PI * 2);
                ctx.fill();
                ctx.globalAlpha = 1;
                
                ctx.restore();
            }
            
            adjustBrightness(color, amount) {
                const num = parseInt(color.replace("#",""), 16);
                const amt = Math.round(2.55 * amount * 100);
                const R = (num >> 16) + amt;
                const G = (num >> 8 & 0x00FF) + amt;
                const B = (num & 0x0000FF) + amt;
                return "#" + (0x1000000 + (R < 255 ? R < 1 ? 0 : R : 255) * 0x10000 +
                    (G < 255 ? G < 1 ? 0 : G : 255) * 0x100 +
                    (B < 255 ? B < 1 ? 0 : B : 255)).toString(16).slice(1);
            }
        }
        
        // æ¯›ç³¸ç‰ã‚¢ã‚¤ãƒ†ãƒ ã‚¯ãƒ©ã‚¹
        class YarnBall {
            constructor(x, y) {
                this.x = x;
                this.y = y;
                this.size = 20 + Math.random() * 10;
                this.bobOffset = Math.random() * Math.PI * 2;
                this.color = this.generateYarnColor();
                this.rotationSpeed = 0.02 + Math.random() * 0.03;
                this.rotation = 0;
                this.glowPulse = Math.random() * Math.PI * 2;
            }
            
            generateYarnColor() {
                const yarnColors = [
                    '#FFD700', '#FF69B4', '#32CD32', '#FF6347',
                    '#9370DB', '#20B2AA', '#FF1493', '#00CED1'
                ];
                return yarnColors[Math.floor(Math.random() * yarnColors.length)];
            }
            
            update() {
                this.rotation += this.rotationSpeed;
                this.glowPulse += 0.05;
            }
            
            draw() {
                ctx.save();
                ctx.translate(this.x, this.y + Math.sin((gameState.time + this.bobOffset) * 0.06) * 5);
                ctx.rotate(this.rotation);
                
                // ã‚°ãƒ­ãƒ¼åŠ¹æœ
                const glowIntensity = 0.5 + Math.sin(this.glowPulse) * 0.3;
                ctx.shadowColor = this.color;
                ctx.shadowBlur = 12 * glowIntensity;
                
                // æ¯›ç³¸ç‰ã®å½±
                ctx.shadowColor = 'rgba(139, 69, 19, 0.3)';
                ctx.shadowBlur = 6;
                ctx.fillStyle = 'rgba(139, 69, 19, 0.2)';
                ctx.beginPath();
                ctx.ellipse(3, 15, this.size * 0.9, this.size * 0.5, 0, 0, Math.PI * 2);
                ctx.fill();
                
                ctx.shadowBlur = 0;
                
                // æ¯›ç³¸ç‰æœ¬ä½“
                ctx.fillStyle = this.color;
                ctx.beginPath();
                ctx.arc(0, 0, this.size, 0, Math.PI * 2);
                ctx.fill();
                
                // æ¯›ç³¸ã®å·»ãæ¨¡æ§˜
                ctx.strokeStyle = this.adjustBrightness(this.color, -0.2);
                ctx.lineWidth = 2;
                ctx.lineCap = 'round';
                
                for (let i = 0; i < 8; i++) {
                    const angle = (i / 8) * Math.PI * 2;
                    const radius = this.size * 0.7;
                    ctx.beginPath();
                    ctx.arc(0, 0, radius, angle, angle + Math.PI * 0.3);
                    ctx.stroke();
                }
                
                // ãƒã‚¤ãƒ©ã‚¤ãƒˆ
                ctx.fillStyle = this.adjustBrightness(this.color, 0.4);
                ctx.globalAlpha = 0.6;
                ctx.beginPath();
                ctx.ellipse(-this.size * 0.3, -this.size * 0.3, this.size * 0.4, this.size * 0.3, 0, 0, Math.PI * 2);
                ctx.fill();
                ctx.globalAlpha = 1;
                
                // æ¯›ç³¸ã®ç«¯
                ctx.strokeStyle = this.adjustBrightness(this.color, -0.1);
                ctx.lineWidth = 3;
                ctx.beginPath();
                ctx.moveTo(this.size * 0.8, 0);
                ctx.lineTo(this.size * 1.2, -this.size * 0.3);
                ctx.stroke();
                
                ctx.restore();
            }
            
            adjustBrightness(color, amount) {
                const num = parseInt(color.replace("#",""), 16);
                const amt = Math.round(2.55 * amount * 100);
                const R = (num >> 16) + amt;
                const G = (num >> 8 & 0x00FF) + amt;
                const B = (num & 0x0000FF) + amt;
                return "#" + (0x1000000 + (R < 255 ? R < 1 ? 0 : R : 255) * 0x10000 +
                    (G < 255 ? G < 1 ? 0 : G : 255) * 0x100 +
                    (B < 255 ? B < 1 ? 0 : B : 255)).toString(16).slice(1);
            }
        }
        
        // é«˜åº¦ãªãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«ã‚·ã‚¹ãƒ†ãƒ 
        function updateParticles() {
            for (let i = gameState.particles.length - 1; i >= 0; i--) {
                let p = gameState.particles[i];
                p.x += p.vx;
                p.y += p.vy;
                p.life--;
                
                // é‡åŠ›åŠ¹æœ
                if (p.type !== 'sparkle') {
                    p.vy += 0.05;
                }
                
                // ç©ºæ°—æŠµæŠ—
                p.vx *= 0.99;
                p.vy *= 0.99;
                
                if (p.life <= 0) {
                    gameState.particles.splice(i, 1);
                } else {
                    ctx.save();
                    
                    const alpha = p.life / p.maxLife;
                    ctx.globalAlpha = alpha;
                    
                    if (p.type === 'yarn') {
                        // æ¯›ç³¸ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«
                        ctx.fillStyle = p.color;
                        ctx.beginPath();
                        ctx.ellipse(p.x, p.y, p.size, p.size * 0.6, gameState.time * 0.1, 0, Math.PI * 2);
                        ctx.fill();
                        
                        // æ¯›ç³¸ã®ç¹Šç¶­
                        ctx.strokeStyle = p.color;
                        ctx.lineWidth = 1;
                        for (let j = 0; j < 3; j++) {
                            ctx.beginPath();
                            ctx.moveTo(p.x + (Math.random() - 0.5) * p.size, p.y);
                            ctx.lineTo(p.x + (Math.random() - 0.5) * p.size, p.y + 2);
                            ctx.stroke();
                        }
                    } else if (p.type === 'special') {
                        // ç‰¹åˆ¥ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«
                        ctx.shadowColor = p.color;
                        ctx.shadowBlur = 8;
                        ctx.fillStyle = p.color;
                        ctx.beginPath();
                        ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
                        ctx.fill();
                        ctx.shadowBlur = 0;
                    } else {
                        // åŸºæœ¬ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«
                        ctx.fillStyle = p.color;
                        ctx.beginPath();
                        ctx.arc(p.x, p.y, p.size || 3, 0, Math.PI * 2);
                        ctx.fill();
                    }
                    
                    ctx.restore();
                }
            }
        }
        
        // ã‚¢ã‚¤ãƒ†ãƒ ç”Ÿæˆã‚·ã‚¹ãƒ†ãƒ 
        function spawnItems() {
            // é­šç”Ÿæˆ
            if (Math.random() < 0.025 && gameState.fishItems.length < 12) {
                gameState.fishItems.push(new YarnFish(
                    Math.random() * (canvas.width - 100) + 50,
                    Math.random() * (canvas.height - 100) + 50
                ));
            }
            
            // æ¯›ç³¸ç‰ç”Ÿæˆï¼ˆãƒ¬ã‚¢ï¼‰
            if (Math.random() < 0.008 && gameState.yarnItems.length < 6) {
                gameState.yarnItems.push(new YarnBall(
                    Math.random() * (canvas.width - 100) + 50,
                    Math.random() * (canvas.height - 100) + 50
                ));
            }
        }
        
        // ã‚²ãƒ¼ãƒ æ©Ÿèƒ½
        function addPenguin() {
            if (gameState.fish >= 10 && gameState.penguins.length < 15) {
                gameState.fish -= 10;
                gameState.penguins.push(new IntelligentPenguin(
                    Math.random() * (canvas.width - 100) + 50,
                    Math.random() * (canvas.height - 100) + 50
                ));
                updateUI();
                createPurchaseEffect();
            }
        }
        
        function upgradeFactory() {
            const cost = 50 * gameState.factoryLevel;
            if (gameState.fish >= cost) {
                gameState.fish -= cost;
                gameState.factoryLevel++;
                gameState.mood += 10;
                updateUI();
                createUpgradeEffect();
            }
        }
        
        function activateTurboMode() {
            if (gameState.fish >= 100 && !gameState.turboMode) {
                gameState.fish -= 100;
                gameState.turboMode = true;
                gameState.turboTimer = 600; // 10ç§’é–“
                updateUI();
                createTurboEffect();
            }
        }
        
        function buyDecoration() {
            if (gameState.fish >= 25) {
                gameState.fish -= 25;
                gameState.mood += 5;
                addDecoration();
                updateUI();
                createDecorationEffect();
            }
        }
        
        function addDecoration() {
            const decorations = ['ğŸŒ¸', 'ğŸŒº', 'ğŸ€', 'â­', 'ğŸŒˆ', 'ğŸ¦‹', 'ğŸŒ™', 'â˜˜ï¸'];
            gameState.decorations.push({
                x: Math.random() * canvas.width,
                y: Math.random() * canvas.height,
                emoji: decorations[Math.floor(Math.random() * decorations.length)],
                size: 20 + Math.random() * 15,
                rotation: Math.random() * Math.PI * 2,
                rotationSpeed: (Math.random() - 0.5) * 0.02
            });
        }
        
        function createPurchaseEffect() {
            for (let i = 0; i < 20; i++) {
                gameState.particles.push({
                    x: canvas.width - 100,
                    y: canvas.height - 100,
                    vx: (Math.random() - 0.5) * 8,
                    vy: -Math.random() * 6 - 2,
                    life: 100,
                    maxLife: 100,
                    color: `hsl(${Math.random() * 60 + 300}, 80%, 70%)`,
                    size: 4 + Math.random() * 6,
                    type: 'special'
                });
            }
        }
        
        function createUpgradeEffect() {
            for (let i = 0; i < 30; i++) {
                gameState.particles.push({
                    x: canvas.width / 2,
                    y: canvas.height / 2,
                    vx: (Math.random() - 0.5) * 10,
                    vy: -Math.random() * 8 - 3,
                    life: 120,
                    maxLife: 120,
                    color: `hsl(${Math.random() * 60 + 45}, 90%, 60%)`,
                    size: 5 + Math.random() * 8,
                    type: 'special'
                });
            }
        }
        
        function createTurboEffect() {
            for (let i = 0; i < 50; i++) {
                gameState.particles.push({
                    x: Math.random() * canvas.width,
                    y: Math.random() * canvas.height,
                    vx: (Math.random() - 0.5) * 12,
                    vy: -Math.random() * 10 - 4,
                    life: 150,
                    maxLife: 150,
                    color: `hsl(${Math.random() * 360}, 90%, 70%)`,
                    size: 6 + Math.random() * 10,
                    type: 'special'
                });
            }
        }
        
        function createDecorationEffect() {
            for (let i = 0; i < 15; i++) {
                gameState.particles.push({
                    x: Math.random() * canvas.width,
                    y: Math.random() * canvas.height,
                    vx: (Math.random() - 0.5) * 6,
                    vy: -Math.random() * 4 - 1,
                    life: 80,
                    maxLife: 80,
                    color: `hsl(${Math.random() * 360}, 70%, 80%)`,
                    size: 3 + Math.random() * 5,
                    type: 'sparkle'
                });
            }
        }
        
        // UIæ›´æ–°
        function updateUI() {
            document.getElementById('fishCount').textContent = gameState.fish;
            document.getElementById('score').textContent = gameState.score;
            document.getElementById('penguinCount').textContent = gameState.penguins.length;
            document.getElementById('yarnCount').textContent = gameState.yarnBalls;
            
            // ãƒ ãƒ¼ãƒ‰ãƒãƒ¼æ›´æ–°
            const moodFill = document.getElementById('moodFill');
            const clampedMood = Math.max(0, Math.min(100, gameState.mood));
            moodFill.style.width = clampedMood + '%';
            
            // ãƒœã‚¿ãƒ³ã®æœ‰åŠ¹/ç„¡åŠ¹çŠ¶æ…‹
            const buttons = document.querySelectorAll('.yarn-button');
            buttons[0].disabled = gameState.fish < 10; // ãƒšãƒ³ã‚®ãƒ³è¿½åŠ 
            buttons[1].disabled = gameState.fish < 50 * gameState.factoryLevel; // ã‚¢ãƒƒãƒ—ã‚°ãƒ¬ãƒ¼ãƒ‰
            buttons[2].disabled = gameState.fish < 100 || gameState.turboMode; // ã‚¿ãƒ¼ãƒœ
            buttons[3].disabled = gameState.fish < 25; // ãƒ‡ã‚³ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³
        }
        
        // èƒŒæ™¯æç”»ï¼ˆæ¯›ç³¸é¢¨ï¼‰
        function drawBackground() {
            // åŸºæœ¬èƒŒæ™¯
            const gradient = ctx.createLinearGradient(0, 0, canvas.width, canvas.height);
            gradient.addColorStop(0, '#F0F8FF');
            gradient.addColorStop(0.5, '#E6F3FF');
            gradient.addColorStop(1, '#DDE9F0');
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // æ¯›ç³¸ã®ç¹”ã‚Šæ¨¡æ§˜
            ctx.strokeStyle = 'rgba(139, 69, 19, 0.1)';
            ctx.lineWidth = 1;
            
            // æ¨ªã®ç¹”ã‚Š
            for (let i = 0; i < canvas.height; i += 20) {
                ctx.beginPath();
                ctx.moveTo(0, i + Math.sin(gameState.time * 0.01 + i * 0.1) * 2);
                ctx.lineTo(canvas.width, i + Math.sin(gameState.time * 0.01 + i * 0.1) * 2);
                ctx.stroke();
            }
            
            // ç¸¦ã®ç¹”ã‚Š
            for (let i = 0; i < canvas.width; i += 20) {
                ctx.beginPath();
                ctx.moveTo(i + Math.sin(gameState.time * 0.008 + i * 0.1) * 2, 0);
                ctx.lineTo(i + Math.sin(gameState.time * 0.008 + i * 0.1) * 2, canvas.height);
                ctx.stroke();
            }
            
            // ãƒ‡ã‚³ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³æç”»
            for (let deco of gameState.decorations) {
                ctx.save();
                ctx.translate(deco.x, deco.y);
                ctx.rotate(deco.rotation);
                ctx.font = deco.size + 'px Arial';
                ctx.textAlign = 'center';
                ctx.fillText(deco.emoji, 0, 0);
                deco.rotation += deco.rotationSpeed;
                ctx.restore();
            }
        }
        
        // éŸ³éŸ¿åŠ¹æœï¼ˆç°¡æ˜“ç‰ˆãƒ»ã‚¨ãƒ©ãƒ¼å¯¾ç­–ï¼‰
        let audioContext = null;
        
        function initAudioContext() {
            if (!audioContext && gameState.soundEnabled) {
                try {
                    audioContext = new (window.AudioContext || window.webkitAudioContext)();
                } catch (e) {
                    console.log('Audio not supported');
                    gameState.soundEnabled = false;
                }
            }
        }
        
        function playSound(frequency, duration) {
            if (!gameState.soundEnabled) return;
            
            try {
                initAudioContext();
                if (!audioContext) return;
                
                if (audioContext.state === 'suspended') {
                    audioContext.resume();
                }
                
                const oscillator = audioContext.createOscillator();
                const gainNode = audioContext.createGain();
                
                oscillator.connect(gainNode);
                gainNode.connect(audioContext.destination);
                
                oscillator.frequency.setValueAtTime(frequency, audioContext.currentTime);
                gainNode.gain.setValueAtTime(0.1, audioContext.currentTime);
                gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + duration);
                
                oscillator.start(audioContext.currentTime);
                oscillator.stop(audioContext.currentTime + duration);
            } catch (e) {
                console.log('Sound error:', e);
            }
        }
        
        // ãƒ¦ãƒ¼ãƒ†ã‚£ãƒªãƒ†ã‚£é–¢æ•°
        function toggleSound() {
            gameState.soundEnabled = !gameState.soundEnabled;
            const button = document.querySelector('.settings-panel .mini-button');
            button.textContent = gameState.soundEnabled ? 'ğŸ”Š' : 'ğŸ”‡';
        }
        
        function saveGame() {
            const saveData = {
                fish: gameState.fish,
                score: gameState.score,
                yarnBalls: gameState.yarnBalls,
                factoryLevel: gameState.factoryLevel,
                mood: gameState.mood,
                penguinCount: gameState.penguins.length,
                decorationCount: gameState.decorations.length,
                savedAt: Date.now()
            };
            localStorage.setItem('yarnPenguinFactory', JSON.stringify(saveData));
            
            // ä¿å­˜ã‚¨ãƒ•ã‚§ã‚¯ãƒˆ
            createPurchaseEffect();
            playSound(523.25, 0.2); // C5
        }
        
        function loadGame() {
            const saveData = localStorage.getItem('yarnPenguinFactory');
            if (saveData) {
                const data = JSON.parse(saveData);
                gameState.fish = data.fish || 0;
                gameState.score = data.score || 0;
                gameState.yarnBalls = data.yarnBalls || 0;
                gameState.factoryLevel = data.factoryLevel || 1;
                gameState.mood = data.mood || 70;
                
                // ãƒšãƒ³ã‚®ãƒ³ã‚’å¾©å…ƒ
                for (let i = 0; i < (data.penguinCount || 3); i++) {
                    gameState.penguins.push(new IntelligentPenguin(
                        Math.random() * (canvas.width - 100) + 50,
                        Math.random() * (canvas.height - 100) + 50
                    ));
                }
                
                // ãƒ‡ã‚³ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³ã‚’å¾©å…ƒ
                for (let i = 0; i < (data.decorationCount || 0); i++) {
                    addDecoration();
                }
            }
        }
        
        function showStats() {
            const stats = `
ğŸ¯ çµ±è¨ˆæƒ…å ± ğŸ¯
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
ğŸŸ ç·é­šæ•°: ${gameState.fish}
â­ ã‚¹ã‚³ã‚¢: ${gameState.score}
ğŸ§¶ æ¯›ç³¸ç‰: ${gameState.yarnBalls}
ğŸ§ ãƒšãƒ³ã‚®ãƒ³æ•°: ${gameState.penguins.length}
ğŸ­ å·¥å ´ãƒ¬ãƒ™ãƒ«: ${gameState.factoryLevel}
ğŸŒŸ ãƒ ãƒ¼ãƒ‰: ${Math.round(gameState.mood)}%
ğŸ¨ ãƒ‡ã‚³ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³: ${gameState.decorations.length}
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
            `;
            alert(stats);
        }
        
        // ãƒ¡ã‚¤ãƒ³ã‚²ãƒ¼ãƒ ãƒ«ãƒ¼ãƒ—
        function gameLoop() {
            gameState.time++;
            
            // ã‚¿ãƒ¼ãƒœãƒ¢ãƒ¼ãƒ‰ç®¡ç†
            if (gameState.turboMode) {
                gameState.turboTimer--;
                if (gameState.turboTimer <= 0) {
                    gameState.turboMode = false;
                }
            }
            
            // ãƒ ãƒ¼ãƒ‰è‡ªç„¶å¤‰åŒ–
            gameState.mood += (Math.random() - 0.5) * 0.1;
            gameState.mood = Math.max(0, Math.min(100, gameState.mood));
            
            // èƒŒæ™¯æç”»
            drawBackground();
            
            // ã‚¢ã‚¤ãƒ†ãƒ ç”Ÿæˆ
            spawnItems();
            
            // é­šæ›´æ–°ãƒ»æç”»
            for (let fish of gameState.fishItems) {
                fish.update();
                fish.draw();
            }
            
            // æ¯›ç³¸ç‰æ›´æ–°ãƒ»æç”»
            for (let yarn of gameState.yarnItems) {
                yarn.update();
                yarn.draw();
            }
            
            // ãƒšãƒ³ã‚®ãƒ³æ›´æ–°ãƒ»æç”»
            for (let penguin of gameState.penguins) {
                penguin.update();
                penguin.draw();
            }
            
            // ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«æ›´æ–°
            updateParticles();
            
            // UIæ›´æ–°
            updateUI();
            
            requestAnimationFrame(gameLoop);
        }
        
        // åˆæœŸåŒ–
        function init() {
            // ã‚»ãƒ¼ãƒ–ãƒ‡ãƒ¼ã‚¿èª­ã¿è¾¼ã¿
            loadGame();
            
            // åˆæœŸãƒšãƒ³ã‚®ãƒ³ãŒè¶³ã‚Šãªã„å ´åˆã¯è¿½åŠ 
            while (gameState.penguins.length < 3) {
                gameState.penguins.push(new IntelligentPenguin(
                    100 + gameState.penguins.length * 150,
                    300 + Math.random() * 100
                ));
            }
            
            // åˆæœŸã‚¢ã‚¤ãƒ†ãƒ é…ç½®
            for (let i = 0; i < 4; i++) {
                gameState.fishItems.push(new YarnFish(
                    Math.random() * (canvas.width - 100) + 50,
                    Math.random() * (canvas.height - 100) + 50
                ));
            }
            
            for (let i = 0; i < 2; i++) {
                gameState.yarnItems.push(new YarnBall(
                    Math.random() * (canvas.width - 100) + 50,
                    Math.random() * (canvas.height - 100) + 50
                ));
            }
            
            updateUI();
            gameLoop();
            
            // æµ®éŠæ¯›ç³¸ç‰ãƒ‡ã‚³ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³
            createFloatingYarns();
        }
        
        function createFloatingYarns() {
            for (let i = 0; i < 5; i++) {
                const yarn = document.createElement('div');
                yarn.className = 'floating-yarn';
                yarn.textContent = 'ğŸ§¶';
                yarn.style.left = Math.random() * window.innerWidth + 'px';
                yarn.style.top = Math.random() * window.innerHeight + 'px';
                yarn.style.animationDelay = Math.random() * 4 + 's';
                document.body.appendChild(yarn);
            }
        }
        
        // ã‚¤ãƒ™ãƒ³ãƒˆãƒªã‚¹ãƒŠãƒ¼
        canvas.addEventListener('click', (e) => {
            // ãƒ¦ãƒ¼ã‚¶ãƒ¼ã‚¤ãƒ³ã‚¿ãƒ©ã‚¯ã‚·ãƒ§ãƒ³æ™‚ã«ã‚ªãƒ¼ãƒ‡ã‚£ã‚ªã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆã‚’åˆæœŸåŒ–
            initAudioContext();
            
            const rect = canvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;
            
            // é­šè¿½åŠ 
            gameState.fishItems.push(new YarnFish(x, y));
            
            // ã‚¯ãƒªãƒƒã‚¯ã‚¨ãƒ•ã‚§ã‚¯ãƒˆ
            for (let i = 0; i < 8; i++) {
                gameState.particles.push({
                    x: x,
                    y: y,
                    vx: (Math.random() - 0.5) * 6,
                    vy: -Math.random() * 4 - 1,
                    life: 60,
                    maxLife: 60,
                    color: `hsl(${Math.random() * 360}, 70%, 70%)`,
                    size: 3 + Math.random() * 4,
                    type: 'sparkle'
                });
            }
            
            playSound(659.25, 0.1); // E5
        });
        
        // ã‚¿ãƒƒãƒãƒ‡ãƒã‚¤ã‚¹å¯¾å¿œ
        canvas.addEventListener('touchstart', (e) => {
            e.preventDefault();
            const rect = canvas.getBoundingClientRect();
            const touch = e.touches[0];
            const x = touch.clientX - rect.left;
            const y = touch.clientY - rect.top;
            
            gameState.fishItems.push(new YarnFish(x, y));
        });
        
        // è‡ªå‹•ä¿å­˜
        setInterval(() => {
            saveGame();
        }, 30000); // 30ç§’ã”ã¨
        
        // ã‚²ãƒ¼ãƒ é–‹å§‹
        init();
    </script>
</body>
</html>
    </script>
</body>
</html>