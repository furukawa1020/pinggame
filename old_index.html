<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>üß∂ „Çè„Åü„Çè„Åü„Éö„É≥„ÇÆ„É≥„Éã„ÉÉ„Éà„ÉØ„Éº„É´„Éâ üß∂</title>
    <link href="https://fonts.googleapis.com/css2?family=Nunito:wght@300;400;600;700;800&display=swap" rel="stylesheet">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            background: radial-gradient(ellipse at center, #F8E6E0, #E8D5C8, #D4C4B0);
            font-family: 'Nunito', sans-serif;
            overflow: hidden;
            user-select: none;
            height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
            position: relative;
        }
        
        /* ÊØõÁ≥∏„ÅÆËÉåÊôØ„ÉÜ„ÇØ„Çπ„ÉÅ„É£ */
        body::before {
            content: '';
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-image: 
                radial-gradient(circle at 20% 80%, rgba(255,255,255,0.1) 1px, transparent 1px),
                radial-gradient(circle at 80% 20%, rgba(255,255,255,0.1) 1px, transparent 1px),
                radial-gradient(circle at 40% 40%, rgba(255,255,255,0.05) 2px, transparent 2px);
            background-size: 50px 50px, 30px 30px, 70px 70px;
            pointer-events: none;
            z-index: 1;
        }
        
        #gameContainer {
            border: 8px solid;
            border-image: linear-gradient(45deg, #8B4513, #D2691E, #CD853F, #DEB887) 1;
            border-radius: 30px;
            box-shadow: 
                0 0 0 4px #F5DEB3,
                0 20px 60px rgba(0,0,0,0.2),
                inset 0 0 0 2px rgba(255,255,255,0.3);
            background: linear-gradient(135deg, #FFF8DC, #F5F5DC);
            position: relative;
            overflow: hidden;
            z-index: 2;
        }
        
        canvas {
            display: block;
            background: 
                radial-gradient(ellipse at 30% 20%, rgba(255,228,196,0.8), transparent 50%),
                radial-gradient(ellipse at 70% 80%, rgba(255,240,245,0.6), transparent 50%),
                linear-gradient(to bottom, #F0F8FF, #E6F3FF, #DDE9F0);
        }
        
        #ui {
            position: absolute;
            top: 20px;
            left: 20px;
            background: rgba(255,255,255,0.9);
            border: 3px solid #DEB887;
            border-radius: 20px;
            padding: 15px 20px;
            backdrop-filter: blur(10px);
            box-shadow: 0 8px 25px rgba(0,0,0,0.1);
            z-index: 10;
            font-weight: 600;
            color: #8B4513;
        }
        
        .stat-item {
            display: flex;
            align-items: center;
            margin: 8px 0;
            font-size: 16px;
        }
        
        .stat-icon {
            font-size: 20px;
            margin-right: 8px;
            filter: drop-shadow(1px 1px 2px rgba(0,0,0,0.2));
        }
        
        .stat-value {
            font-weight: 800;
            color: #CD853F;
            min-width: 60px;
            text-align: right;
        }
        
        #title {
            position: absolute;
            top: -60px;
            left: 50%;
            transform: translateX(-50%);
            font-size: 32px;
            font-weight: 800;
            background: linear-gradient(45deg, #8B4513, #D2691E, #CD853F);
            background-clip: text;
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            filter: drop-shadow(2px 2px 4px rgba(0,0,0,0.3));
            text-shadow: none;
            z-index: 3;
        }
        
        .control-panel {
            position: absolute;
            bottom: 20px;
            right: 20px;
            display: flex;
            flex-direction: column;
            gap: 12px;
            z-index: 10;
        }
        
        .yarn-button {
            background: linear-gradient(135deg, #FF69B4, #FF1493, #DC143C);
            border: 3px solid #FFF;
            border-radius: 25px;
            padding: 12px 24px;
            color: white;
            font-weight: 700;
            cursor: pointer;
            font-family: 'Nunito', sans-serif;
            font-size: 14px;
            box-shadow: 
                0 6px 20px rgba(255,20,147,0.4),
                inset 0 1px 0 rgba(255,255,255,0.3);
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            position: relative;
            overflow: hidden;
        }
        
        .yarn-button::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255,255,255,0.3), transparent);
            transition: left 0.5s;
        }
        
        .yarn-button:hover {
            transform: translateY(-3px) scale(1.05);
            box-shadow: 
                0 12px 30px rgba(255,20,147,0.6),
                inset 0 1px 0 rgba(255,255,255,0.4);
        }
        
        .yarn-button:hover::before {
            left: 100%;
        }
        
        .yarn-button:active {
            transform: translateY(-1px) scale(1.02);
        }
        
        .special-button {
            background: linear-gradient(135deg, #FFD700, #FFA500, #FF8C00);
            box-shadow: 
                0 6px 20px rgba(255,215,0,0.4),
                inset 0 1px 0 rgba(255,255,255,0.3);
        }
        
        .special-button:hover {
            box-shadow: 
                0 12px 30px rgba(255,215,0,0.6),
                inset 0 1px 0 rgba(255,255,255,0.4);
        }
        
        .mood-indicator {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(255,255,255,0.9);
            border: 3px solid #DEB887;
            border-radius: 20px;
            padding: 12px 16px;
            backdrop-filter: blur(10px);
            box-shadow: 0 8px 25px rgba(0,0,0,0.1);
            z-index: 10;
        }
        
        .mood-bar {
            width: 120px;
            height: 8px;
            background: #E0E0E0;
            border-radius: 4px;
            overflow: hidden;
            margin-top: 5px;
        }
        
        .mood-fill {
            height: 100%;
            background: linear-gradient(90deg, #FF69B4, #FFB6C1, #FFC0CB);
            border-radius: 4px;
            transition: width 0.3s ease;
        }
        
        .settings-panel {
            position: absolute;
            bottom: 20px;
            left: 20px;
            display: flex;
            gap: 10px;
            z-index: 10;
        }
        
        .mini-button {
            width: 50px;
            height: 50px;
            border-radius: 50%;
            border: 3px solid #FFF;
            background: linear-gradient(135deg, #87CEEB, #4169E1);
            color: white;
            font-size: 20px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: 0 4px 12px rgba(0,0,0,0.2);
            transition: all 0.3s ease;
        }
        
        .mini-button:hover {
            transform: translateY(-2px) scale(1.1);
            box-shadow: 0 6px 18px rgba(0,0,0,0.3);
        }
        
        @keyframes yarnFloat {
            0%, 100% { transform: translateY(0px) rotate(0deg); }
            33% { transform: translateY(-10px) rotate(120deg); }
            66% { transform: translateY(-5px) rotate(240deg); }
        }
        
        .floating-yarn {
            position: absolute;
            font-size: 24px;
            animation: yarnFloat 4s ease-in-out infinite;
            pointer-events: none;
            z-index: 5;
        }
        
        /* „Éë„Éï„Ç©„Éº„Éû„É≥„ÇπÊúÄÈÅ©Âåñ */
        canvas {
            image-rendering: optimizeSpeed;
            image-rendering: -moz-crisp-edges;
            image-rendering: -webkit-optimize-contrast;
            image-rendering: optimize-contrast;
        }
    </style>
</head>
<body>
    <div id="gameContainer">
        <div id="title">üß∂ „Çè„Åü„Çè„Åü„Éö„É≥„ÇÆ„É≥„Éã„ÉÉ„Éà„ÉØ„Éº„É´„Éâ üß∂</div>
        
        <div id="ui">
            <div class="stat-item">
                <span class="stat-icon">üêü</span>
                <span>„Åï„Åã„Å™: </span>
                <span class="stat-value" id="fishCount">0</span>
            </div>
            <div class="stat-item">
                <span class="stat-icon">‚≠ê</span>
                <span>„Çπ„Ç≥„Ç¢: </span>
                <span class="stat-value" id="score">0</span>
            </div>
            <div class="stat-item">
                <span class="stat-icon">üêß</span>
                <span>„Éö„É≥„ÇÆ„É≥: </span>
                <span class="stat-value" id="penguinCount">3</span>
            </div>
            <div class="stat-item">
                <span class="stat-icon">üß∂</span>
                <span>ÊØõÁ≥∏Áéâ: </span>
                <span class="stat-value" id="yarnCount">0</span>
            </div>
        </div>
        
        <div class="mood-indicator">
            <div style="font-weight: 600; color: #8B4513; font-size: 14px;">üåü „Éï„Ç°„ÇØ„Éà„É™„Éº„É†„Éº„Éâ</div>
            <div class="mood-bar">
                <div class="mood-fill" id="moodFill" style="width: 70%"></div>
            </div>
        </div>
        
        <canvas id="gameCanvas" width="900" height="700"></canvas>
        
        <div class="control-panel">
            <button class="yarn-button" onclick="addPenguin()">
                üêß „Éö„É≥„ÇÆ„É≥ËøΩÂä† („Ç≥„Çπ„Éà: 10üêü)
            </button>
            <button class="yarn-button" onclick="upgradeFactory()">
                ‚ö° Â∑•Â†¥„Ç¢„ÉÉ„Éó„Ç∞„É¨„Éº„Éâ („Ç≥„Çπ„Éà: 50üêü)
            </button>
            <button class="yarn-button special-button" onclick="activateTurboMode()">
                üöÄ „Çø„Éº„Éú„É¢„Éº„Éâ („Ç≥„Çπ„Éà: 100üêü)
            </button>
            <button class="yarn-button" onclick="buyDecoration()">
                üé® „Éá„Ç≥„É¨„Éº„Ç∑„Éß„É≥ („Ç≥„Çπ„Éà: 25üêü)
            </button>
        </div>
        
        <div class="settings-panel">
            <button class="mini-button" onclick="toggleSound()" title="Èü≥ÈüøÂäπÊûú">üîä</button>
            <button class="mini-button" onclick="saveGame()" title="„Ç≤„Éº„É†‰øùÂ≠ò">üíæ</button>
            <button class="mini-button" onclick="showStats()" title="Áµ±Ë®àÊÉÖÂ†±">üìä</button>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        
        // „Ç≤„Éº„É†Áä∂ÊÖãÁÆ°ÁêÜ
        let gameState = {
            fish: 0,
            score: 0,
            yarnBalls: 0,
            factoryLevel: 1,
            mood: 70,
            turboMode: false,
            turboTimer: 0,
            penguins: [],
            fishItems: [],
            yarnItems: [],
            particles: [],
            decorations: [],
            time: 0,
            soundEnabled: true,
            savedAt: Date.now()
        };
        
        // ÊúÄÊñ∞Âºè„Éã„É•„Éº„É©„É´„Éç„ÉÉ„Éà„ÉØ„Éº„ÇØ„ÇØ„É©„ÇπÔºàËªΩÈáèÁâàÔºâ
        class MiniNeuralNetwork {
            constructor(inputSize, hiddenSize, outputSize) {
                this.inputSize = inputSize;
                this.hiddenSize = hiddenSize;
                this.outputSize = outputSize;
                
                // Èáç„ÅøÂàùÊúüÂåñÔºàXavierÂàùÊúüÂåñÔºâ
                this.weightsIH = this.initializeWeights(inputSize, hiddenSize);
                this.weightsHO = this.initializeWeights(hiddenSize, outputSize);
                this.biasH = new Array(hiddenSize).fill(0).map(() => (Math.random() - 0.5) * 0.1);
                this.biasO = new Array(outputSize).fill(0).map(() => (Math.random() - 0.5) * 0.1);
                
                // Â≠¶ÁøíÁéá
                this.learningRate = 0.01;
            }
            
            initializeWeights(rows, cols) {
                const weights = [];
                const limit = Math.sqrt(6 / (rows + cols));
                for (let i = 0; i < rows; i++) {
                    weights[i] = [];
                    for (let j = 0; j < cols; j++) {
                        weights[i][j] = (Math.random() - 0.5) * 2 * limit;
                    }
                }
                return weights;
            }
            
            sigmoid(x) {
                return 1 / (1 + Math.exp(-Math.max(-500, Math.min(500, x))));
            }
            
            tanh(x) {
                return Math.tanh(Math.max(-500, Math.min(500, x)));
            }
            
            forward(inputs) {
                // Èö†„ÇåÂ±§„ÅÆË®àÁÆó
                const hidden = [];
                for (let i = 0; i < this.hiddenSize; i++) {
                    let sum = this.biasH[i];
                    for (let j = 0; j < this.inputSize; j++) {
                        sum += inputs[j] * this.weightsIH[j][i];
                    }
                    hidden[i] = this.tanh(sum);
                }
                
                // Âá∫ÂäõÂ±§„ÅÆË®àÁÆó
                const outputs = [];
                for (let i = 0; i < this.outputSize; i++) {
                    let sum = this.biasO[i];
                    for (let j = 0; j < this.hiddenSize; j++) {
                        sum += hidden[j] * this.weightsHO[j][i];
                    }
                    outputs[i] = this.sigmoid(sum);
                }
                
                return { hidden, outputs };
            }
            
            // Âº∑ÂåñÂ≠¶ÁøíÁöÑ„Å™Èáç„ÅøÊõ¥Êñ∞
            updateWeights(inputs, reward, action) {
                const { hidden, outputs } = this.forward(inputs);
                
                // Á∞°Âçò„Å™Èáç„ÅøÊõ¥Êñ∞ÔºàÊñπÁ≠ñÂãæÈÖçÁöÑÔºâ
                const delta = reward * this.learningRate;
                
                // Âá∫ÂäõÂ±§„ÅÆÊõ¥Êñ∞
                for (let i = 0; i < this.outputSize; i++) {
                    this.biasO[i] += delta * (i === action ? 1 : -0.1);
                    for (let j = 0; j < this.hiddenSize; j++) {
                        this.weightsHO[j][i] += delta * hidden[j] * (i === action ? 1 : -0.1);
                    }
                }
                
                // Èö†„ÇåÂ±§„ÅÆÊõ¥Êñ∞
                for (let i = 0; i < this.hiddenSize; i++) {
                    this.biasH[i] += delta * 0.1;
                    for (let j = 0; j < this.inputSize; j++) {
                        this.weightsIH[j][i] += delta * inputs[j] * 0.1;
                    }
                }
            }
        }
        
        // ÈÄ≤Âåñ„Åó„Åü„Éö„É≥„ÇÆ„É≥„ÇØ„É©„ÇπÔºà„Éã„É•„Éº„É©„É´„Éç„ÉÉ„Éà„ÉØ„Éº„ÇØÊê≠ËºâÔºâ
        class IntelligentPenguin {
            constructor(x, y) {
                this.x = x;
                this.y = y;
                this.targetX = x;
                this.targetY = y;
                this.baseSpeed = 0.8 + Math.random() * 0.7;
                this.size = 30 + Math.random() * 15;
                this.color = this.generateYarnColor();
                this.state = 'idle';
                this.workTimer = 0;
                this.happiness = 50 + Math.random() * 50;
                this.energy = 100;
                this.intelligence = 0.5 + Math.random() * 0.5;
                this.personality = Math.random();
                this.direction = Math.random() > 0.5 ? 1 : -1;
                this.lastAction = 0;
                this.yarnTexture = this.generateYarnTexture();
                
                // „Éã„É•„Éº„É©„É´„Éç„ÉÉ„Éà„ÉØ„Éº„ÇØÂàùÊúüÂåñ
                this.brain = new MiniNeuralNetwork(8, 12, 4); // 8ÂÖ•Âäõ, 12Èö†„Çå, 4Âá∫Âäõ
                this.memory = [];
                this.lastReward = 0;
                this.actionHistory = [];
                
                // „Ç¢„Éã„É°„Éº„Ç∑„Éß„É≥Áî®
                this.wobbleOffset = Math.random() * Math.PI * 2;
                this.blinkTimer = Math.random() * 200;
                this.isBlinking = false;
                
                // ÊØõÁ≥∏È¢®„ÉÜ„ÇØ„Çπ„ÉÅ„É£
                this.stitchPattern = this.generateStitchPattern();
            }
            
            generateYarnColor() {
                const yarnColors = [
                    '#E6B3BA', '#F4D3AE', '#B8E6B8', '#A8D8EA',
                    '#FFD93D', '#FF9FF3', '#A8DADC', '#F1C0E8'
                ];
                return yarnColors[Math.floor(Math.random() * yarnColors.length)];
            }
            
            generateYarnTexture() {
                return {
                    roughness: Math.random() * 0.3 + 0.1,
                    shine: Math.random() * 0.5 + 0.2,
                    pattern: Math.floor(Math.random() * 3)
                };
            }
            
            generateStitchPattern() {
                const patterns = [];
                for (let i = 0; i < 8; i++) {
                    patterns.push({
                        x: (Math.random() - 0.5) * this.size * 0.8,
                        y: (Math.random() - 0.5) * this.size * 0.8,
                        size: 2 + Math.random() * 3
                    });
                }
                return patterns;
            }
            
            // È´òÂ∫¶„Å™AIÊÄùËÄÉ„Éó„É≠„Çª„Çπ
            think() {
                // Áí∞Â¢ÉË™çË≠òÔºà8Ê¨°ÂÖÉÂÖ•Âäõ„Éô„ÇØ„Éà„É´Ôºâ
                const inputs = this.perceiveEnvironment();
                
                // „Éã„É•„Éº„É©„É´„Éç„ÉÉ„Éà„ÉØ„Éº„ÇØ„ÅßË°åÂãïÊ±∫ÂÆö
                const { outputs } = this.brain.forward(inputs);
                
                // Ë°åÂãïÈÅ∏ÊäûÔºàŒµ-„Ç∞„É™„Éº„Éá„Ç£Ê≥ïÔºâ
                let action;
                if (Math.random() < 0.1) { // 10%„ÅÆÁ¢∫Áéá„Åß„É©„É≥„ÉÄ„É†Êé¢Á¥¢
                    action = Math.floor(Math.random() * 4);
                } else {
                    action = outputs.indexOf(Math.max(...outputs));
                }
                
                // Ë°åÂãïÂÆüË°å
                this.executeAction(action);
                
                // Â†±ÈÖ¨Ë®àÁÆó„Å®Â≠¶Áøí
                const reward = this.calculateReward();
                if (this.actionHistory.length > 0) {
                    const lastInput = this.actionHistory[this.actionHistory.length - 1].input;
                    const lastAction = this.actionHistory[this.actionHistory.length - 1].action;
                    this.brain.updateWeights(lastInput, reward, lastAction);
                }
                
                // Â±•Ê≠¥‰øùÂ≠ò
                this.actionHistory.push({ input: inputs, action, reward });
                if (this.actionHistory.length > 10) {
                    this.actionHistory.shift();
                }
                
                // Âü∫Êú¨ÁöÑ„Å™ÁîüÁêÜÁä∂ÊÖãÊõ¥Êñ∞
                this.energy -= 0.1;
                if (this.energy < 0) this.energy = 0;
                if (this.energy < 20) this.happiness -= 0.5;
                
                // „Åæ„Å∞„Åü„ÅçÂà∂Âæ°
                this.blinkTimer++;
                if (this.blinkTimer > 180 + Math.random() * 120) {
                    this.isBlinking = true;
                    setTimeout(() => this.isBlinking = false, 150);
                    this.blinkTimer = 0;
                }
            }
            
            perceiveEnvironment() {
                const nearestFish = this.findNearestFish();
                const nearestPenguin = this.findNearestPenguin();
                const nearestYarn = this.findNearestYarn();
                
                return [
                    this.x / canvas.width,                                    // Ëá™ÂàÜ„ÅÆX‰ΩçÁΩÆÔºàÊ≠£Ë¶èÂåñÔºâ
                    this.y / canvas.height,                                   // Ëá™ÂàÜ„ÅÆY‰ΩçÁΩÆÔºàÊ≠£Ë¶èÂåñÔºâ
                    this.happiness / 100,                                     // Âπ∏Á¶èÂ∫¶
                    this.energy / 100,                                        // „Ç®„Éç„É´„ÇÆ„Éº
                    nearestFish ? this.distanceTo(nearestFish.x, nearestFish.y) / 500 : 1, // ÊúÄËøëÂÇçÈ≠ö„Å∏„ÅÆË∑ùÈõ¢
                    nearestPenguin ? this.distanceTo(nearestPenguin.x, nearestPenguin.y) / 500 : 1, // ÊúÄËøëÂÇç„Éö„É≥„ÇÆ„É≥„Å∏„ÅÆË∑ùÈõ¢
                    nearestYarn ? this.distanceTo(nearestYarn.x, nearestYarn.y) / 500 : 1, // ÊúÄËøëÂÇçÊØõÁ≥∏„Å∏„ÅÆË∑ùÈõ¢
                    gameState.mood / 100                                      // ÂÖ®‰Ωì„É†„Éº„Éâ
                ];
            }
            
            executeAction(action) {
                switch (action) {
                    case 0: // È≠ö„ÇíÊé¢„Åó„Å´Ë°å„Åè
                        this.goToNearestFish();
                        break;
                    case 1: // ÊØõÁ≥∏Áéâ„ÇíÊé¢„Åó„Å´Ë°å„Åè
                        this.goToNearestYarn();
                        break;
                    case 2: // ‰ªñ„ÅÆ„Éö„É≥„ÇÆ„É≥„Å®Á§æ‰∫§
                        this.socializeWithNearestPenguin();
                        break;
                    case 3: // ‰ºëÊÜ©
                        this.rest();
                        break;
                }
            }
            
            calculateReward() {
                let reward = 0;
                
                // Âü∫Êú¨ÁîüÂ≠òÂ†±ÈÖ¨
                reward += 0.1;
                
                // Âπ∏Á¶èÂ∫¶„Å´Âü∫„Å•„ÅèÂ†±ÈÖ¨
                reward += (this.happiness - 50) / 100;
                
                // È≠öÂèéÈõÜÂ†±ÈÖ¨
                if (this.state === 'working' && this.workTimer > 0) {
                    reward += 0.5;
                }
                
                // „Ç®„Éç„É´„ÇÆ„ÉºÁÆ°ÁêÜÂ†±ÈÖ¨
                if (this.energy > 80) reward += 0.2;
                if (this.energy < 20) reward -= 0.3;
                
                // Á§æ‰∫§Â†±ÈÖ¨
                const nearbyPenguins = this.countNearbyPenguins();
                if (nearbyPenguins > 0 && nearbyPenguins < 3) {
                    reward += 0.3;
                }
                
                return reward;
            }
            
            findNearestFish() {
                if (gameState.fishItems.length === 0) return null;
                let nearest = gameState.fishItems[0];
                let minDist = this.distanceTo(nearest.x, nearest.y);
                
                for (let fish of gameState.fishItems) {
                    let dist = this.distanceTo(fish.x, fish.y);
                    if (dist < minDist) {
                        minDist = dist;
                        nearest = fish;
                    }
                }
                return nearest;
            }
            
            findNearestPenguin() {
                let nearest = null;
                let minDist = Infinity;
                
                for (let penguin of gameState.penguins) {
                    if (penguin === this) continue;
                    let dist = this.distanceTo(penguin.x, penguin.y);
                    if (dist < minDist) {
                        minDist = dist;
                        nearest = penguin;
                    }
                }
                return nearest;
            }
            
            findNearestYarn() {
                if (gameState.yarnItems.length === 0) return null;
                let nearest = gameState.yarnItems[0];
                let minDist = this.distanceTo(nearest.x, nearest.y);
                
                for (let yarn of gameState.yarnItems) {
                    let dist = this.distanceTo(yarn.x, yarn.y);
                    if (dist < minDist) {
                        minDist = dist;
                        nearest = yarn;
                    }
                }
                return nearest;
            }
            
            countNearbyPenguins() {
                let count = 0;
                for (let penguin of gameState.penguins) {
                    if (penguin !== this && this.distanceTo(penguin.x, penguin.y) < 100) {
                        count++;
                    }
                }
                return count;
            }
            
            goToNearestFish() {
                const fish = this.findNearestFish();
                if (fish) {
                    this.targetX = fish.x;
                    this.targetY = fish.y;
                    this.state = 'moving';
                }
            }
            
            goToNearestYarn() {
                const yarn = this.findNearestYarn();
                if (yarn) {
                    this.targetX = yarn.x;
                    this.targetY = yarn.y;
                    this.state = 'moving';
                }
            }
            
            socializeWithNearestPenguin() {
                const penguin = this.findNearestPenguin();
                if (penguin) {
                    this.targetX = penguin.x + (Math.random() - 0.5) * 100;
                    this.targetY = penguin.y + (Math.random() - 0.5) * 100;
                    this.state = 'moving';
                    this.happiness += 5;
                }
            }
            
            rest() {
                this.state = 'idle';
                this.energy += 2;
                if (this.energy > 100) this.energy = 100;
            }
            
            distanceTo(x, y) {
                return Math.sqrt((this.x - x) ** 2 + (this.y - y) ** 2);
            }
            
            reachedTarget() {
                return this.distanceTo(this.targetX, this.targetY) < 8;
            }
            
            collectNearbyItems() {
                // È≠öÂèéÈõÜ
                for (let i = gameState.fishItems.length - 1; i >= 0; i--) {
                    let fish = gameState.fishItems[i];
                    if (this.distanceTo(fish.x, fish.y) < 50) {
                        gameState.fishItems.splice(i, 1);
                        gameState.fish++;
                        gameState.score += 15;
                        this.happiness += 15;
                        this.energy += 10;
                        this.createYarnParticles();
                        break;
                    }
                }
                
                // ÊØõÁ≥∏ÁéâÂèéÈõÜ
                for (let i = gameState.yarnItems.length - 1; i >= 0; i--) {
                    let yarn = gameState.yarnItems[i];
                    if (this.distanceTo(yarn.x, yarn.y) < 50) {
                        gameState.yarnItems.splice(i, 1);
                        gameState.yarnBalls++;
                        gameState.score += 25;
                        this.happiness += 20;
                        this.createSpecialParticles();
                        break;
                    }
                }
            }
            
            createYarnParticles() {
                for (let i = 0; i < 12; i++) {
                    gameState.particles.push({
                        x: this.x,
                        y: this.y - 15,
                        vx: (Math.random() - 0.5) * 6,
                        vy: -Math.random() * 4 - 2,
                        life: 80,
                        maxLife: 80,
                        color: `hsl(${Math.random() * 60 + 320}, 75%, 75%)`,
                        size: 3 + Math.random() * 4,
                        type: 'yarn'
                    });
                }
            }
            
            createSpecialParticles() {
                for (let i = 0; i < 16; i++) {
                    gameState.particles.push({
                        x: this.x,
                        y: this.y - 20,
                        vx: (Math.random() - 0.5) * 8,
                        vy: -Math.random() * 6 - 3,
                        life: 120,
                        maxLife: 120,
                        color: `hsl(${Math.random() * 360}, 80%, 70%)`,
                        size: 4 + Math.random() * 6,
                        type: 'special'
                    });
                }
            }
            
            update() {
                this.think();
                
                // „Çπ„É†„Éº„Ç∫„Å™ÁßªÂãïÔºà„Ç§„Éº„Ç∏„É≥„Ç∞Ôºâ
                if (this.state === 'moving') {
                    let dx = this.targetX - this.x;
                    let dy = this.targetY - this.y;
                    let speed = this.baseSpeed * (gameState.turboMode ? 2 : 1);
                    
                    this.x += dx * speed * 0.08;
                    this.y += dy * speed * 0.08;
                    
                    this.direction = dx > 0 ? 1 : -1;
                    
                    if (this.reachedTarget()) {
                        this.state = 'working';
                        this.workTimer = 40 + Math.random() * 80;
                    }
                } else if (this.state === 'working') {
                    this.workTimer--;
                    if (this.workTimer <= 0) {
                        this.state = 'idle';
                        this.collectNearbyItems();
                    }
                }
                
                // Â¢ÉÁïå„ÉÅ„Çß„ÉÉ„ÇØÔºà„ÇΩ„Éï„Éà„Éê„Ç¶„É≥„ÇπÔºâ
                const margin = this.size;
                if (this.x < margin) {
                    this.x = margin;
                    this.targetX = margin + 50;
                }
                if (this.x > canvas.width - margin) {
                    this.x = canvas.width - margin;
                    this.targetX = canvas.width - margin - 50;
                }
                if (this.y < margin) {
                    this.y = margin;
                    this.targetY = margin + 50;
                }
                if (this.y > canvas.height - margin) {
                    this.y = canvas.height - margin;
                    this.targetY = canvas.height - margin - 50;
                }
                
                // Âπ∏Á¶èÂ∫¶„ÅÆËá™ÁÑ∂Â§âÂåñ
                this.happiness += (Math.random() - 0.5) * 0.3;
                this.happiness = Math.max(0, Math.min(100, this.happiness));
            }
            
            drawYarnTexture() {
                // „Éö„É≥„ÇÆ„É≥„ÅÆ‰ΩìÔºàÊØõÁ≥∏È¢®Ôºâ
                ctx.save();
                
                // ‰Ωì„ÅÆÂü∫Êú¨ÂΩ¢Ôºà„Éö„É≥„ÇÆ„É≥„Çâ„Åó„ÅÑÊ•ïÂÜÜÔºâ
                ctx.fillStyle = '#2C3E50'; // „Éö„É≥„ÇÆ„É≥„ÅÆÈªí„ÅÑÈÉ®ÂàÜ
                ctx.beginPath();
                ctx.ellipse(0, 5, this.size * 0.8, this.size * 1.1, 0, 0, Math.PI * 2);
                ctx.fill();
                
                // „ÅäËÖπ„ÅÆÁôΩ„ÅÑÈÉ®ÂàÜ
                ctx.fillStyle = '#FFFEF7';
                ctx.beginPath();
                ctx.ellipse(0, 8, this.size * 0.55, this.size * 0.9, 0, 0, Math.PI * 2);
                ctx.fill();
                
                // ÊØõÁ≥∏„ÅÆÁ∏´„ÅÑÁõÆ„Éë„Çø„Éº„É≥Ôºà‰Ωì„Å´Ôºâ
                ctx.strokeStyle = 'rgba(139, 69, 19, 0.3)';
                ctx.lineWidth = 1;
                ctx.lineCap = 'round';
                
                for (let stitch of this.stitchPattern) {
                    ctx.beginPath();
                    ctx.moveTo(stitch.x - stitch.size * 0.5, stitch.y);
                    ctx.lineTo(stitch.x + stitch.size * 0.5, stitch.y);
                    ctx.stroke();
                }
                
                // „Éö„É≥„ÇÆ„É≥„ÅÆÈ†≠
                ctx.fillStyle = '#2C3E50';
                ctx.beginPath();
                ctx.ellipse(0, -this.size * 0.6, this.size * 0.7, this.size * 0.6, 0, 0, Math.PI * 2);
                ctx.fill();
                
                ctx.restore();
            }
            
            adjustBrightness(color, amount) {
                // Ëâ≤„ÅÆÊòéÂ∫¶„ÇíË™øÊï¥
                const num = parseInt(color.replace("#",""), 16);
                const amt = Math.round(2.55 * amount * 100);
                const R = (num >> 16) + amt;
                const G = (num >> 8 & 0x00FF) + amt;
                const B = (num & 0x0000FF) + amt;
                return "#" + (0x1000000 + (R < 255 ? R < 1 ? 0 : R : 255) * 0x10000 +
                    (G < 255 ? G < 1 ? 0 : G : 255) * 0x100 +
                    (B < 255 ? B < 1 ? 0 : B : 255)).toString(16).slice(1);
            }
            
            draw() {
                ctx.save();
                ctx.translate(this.x, this.y);
                ctx.scale(this.direction, 1);
                
                // „ÅΩ„Çà„ÅΩ„Çà„Ç¢„Éã„É°„Éº„Ç∑„Éß„É≥Ôºà„Çà„ÇäÊüî„Çâ„Åã„ÅèÔºâ
                let wobble = Math.sin((gameState.time + this.wobbleOffset) * 0.08) * 2;
                let stretch = 1 + Math.sin((gameState.time + this.wobbleOffset) * 0.12) * 0.03;
                ctx.translate(0, wobble);
                ctx.scale(stretch, 1/stretch);
                
                // „ÇΩ„Éï„Éà„Ç∑„É£„Éâ„Ç¶
                ctx.fillStyle = 'rgba(139, 69, 19, 0.2)';
                ctx.beginPath();
                ctx.ellipse(2, this.size + 8, this.size * 0.9, this.size * 0.4, 0, 0, Math.PI * 2);
                ctx.fill();
                
                // „Éö„É≥„ÇÆ„É≥„ÅÆ‰ΩìÔºàÊØõÁ≥∏„ÉÜ„ÇØ„Çπ„ÉÅ„É£Ôºâ
                this.drawYarnTexture();
                
                // „Éö„É≥„ÇÆ„É≥„ÅÆÁøº
                ctx.fillStyle = '#2C3E50';
                ctx.beginPath();
                ctx.ellipse(-this.size * 0.6, 0, this.size * 0.25, this.size * 0.7, -0.3, 0, Math.PI * 2);
                ctx.fill();
                ctx.beginPath();
                ctx.ellipse(this.size * 0.6, 0, this.size * 0.25, this.size * 0.7, 0.3, 0, Math.PI * 2);
                ctx.fill();
                
                // „Éö„É≥„ÇÆ„É≥„ÅÆË∂≥
                ctx.fillStyle = '#FFB347';
                ctx.beginPath();
                ctx.ellipse(-this.size * 0.2, this.size + 5, 8, 12, 0, 0, Math.PI * 2);
                ctx.fill();
                ctx.beginPath();
                ctx.ellipse(this.size * 0.2, this.size + 5, 8, 12, 0, 0, Math.PI * 2);
                ctx.fill();
                
                // „Éö„É≥„ÇÆ„É≥„ÅÆ„Åè„Å°„Å∞„Åó
                ctx.fillStyle = '#FFB347';
                ctx.beginPath();
                ctx.moveTo(-this.size * 0.45, -this.size * 0.6);
                ctx.lineTo(-this.size * 0.65, -this.size * 0.55);
                ctx.lineTo(-this.size * 0.45, -this.size * 0.5);
                ctx.closePath();
                ctx.fill();
                
                // „Éö„É≥„ÇÆ„É≥„ÅÆÁõÆÔºà„Åæ„Å∞„Åü„ÅçÂØæÂøúÔºâ
                if (!this.isBlinking) {
                    // ÁôΩÁõÆ
                    ctx.fillStyle = '#FFFFFF';
                    ctx.beginPath();
                    ctx.ellipse(-this.size * 0.25, -this.size * 0.7, 8, 10, 0, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.beginPath();
                    ctx.ellipse(this.size * 0.25, -this.size * 0.7, 8, 10, 0, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // Áû≥
                    ctx.fillStyle = '#2C3E50';
                    ctx.beginPath();
                    ctx.ellipse(-this.size * 0.25, -this.size * 0.7, 4, 6, 0, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.beginPath();
                    ctx.ellipse(this.size * 0.25, -this.size * 0.7, 4, 6, 0, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // „Éè„Ç§„É©„Ç§„Éà
                    ctx.fillStyle = '#FFFFFF';
                    ctx.beginPath();
                    ctx.ellipse(-this.size * 0.25 + 2, -this.size * 0.7 - 2, 2, 3, 0, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.beginPath();
                    ctx.ellipse(this.size * 0.25 + 2, -this.size * 0.7 - 2, 2, 3, 0, 0, Math.PI * 2);
                    ctx.fill();
                } else {
                    // „Åæ„Å∞„Åü„Åç
                    ctx.strokeStyle = '#2C3E50';
                    ctx.lineWidth = 3;
                    ctx.lineCap = 'round';
                    ctx.beginPath();
                    ctx.moveTo(-this.size * 0.33, -this.size * 0.7);
                    ctx.lineTo(-this.size * 0.17, -this.size * 0.7);
                    ctx.stroke();
                    ctx.beginPath();
                    ctx.moveTo(this.size * 0.17, -this.size * 0.7);
                    ctx.lineTo(this.size * 0.33, -this.size * 0.7);
                    ctx.stroke();
                }
                
                // Âπ∏„ÅõÂ∫¶„Å´„Çà„ÇãË°®ÊÉÖÂ§âÂåñ
                if (this.happiness > 80) {
                    ctx.strokeStyle = '#FF69B4';
                    ctx.lineWidth = 2;
                    ctx.lineCap = 'round';
                    ctx.beginPath();
                    ctx.arc(0, -this.size * 0.45, 12, 0.2, Math.PI - 0.2);
                    ctx.stroke();
                } else if (this.happiness < 30) {
                    ctx.strokeStyle = '#4169E1';
                    ctx.lineWidth = 2;
                    ctx.lineCap = 'round';
                    ctx.beginPath();
                    ctx.arc(0, -this.size * 0.4, 10, Math.PI + 0.2, 2 * Math.PI - 0.2);
                    ctx.stroke();
                }
                
                // „Ç®„Éç„É´„ÇÆ„ÉºÁä∂ÊÖã„ÅÆË°®Á§∫
                if (this.energy < 30) {
                    ctx.fillStyle = 'rgba(255, 255, 0, 0.7)';
                    ctx.font = '14px Nunito';
                    ctx.textAlign = 'center';
                    ctx.fillText('üí§', 0, -this.size - 20);
                }
                
                // ‰ΩúÊ•≠‰∏≠„Ç®„Éï„Çß„ÇØ„Éà
                if (this.state === 'working') {
                    const sparkles = ['‚ú®', '‚≠ê', 'üí´', 'üåü'];
                    ctx.fillStyle = '#FFD700';
                    ctx.font = '16px Nunito';
                    ctx.textAlign = 'center';
                    ctx.fillText(sparkles[Math.floor(gameState.time / 20) % sparkles.length], 0, -this.size - 25);
                }
                
                // ÊØõÁ≥∏„ÅÆË≥™ÊÑü„Ç®„Éï„Çß„ÇØ„Éà
                if (Math.random() < 0.1) {
                    ctx.strokeStyle = 'rgba(255, 255, 255, 0.5)';
                    ctx.lineWidth = 1;
                    ctx.globalAlpha = 0.4;
                    for (let i = 0; i < 2; i++) {
                        ctx.beginPath();
                        ctx.moveTo((Math.random() - 0.5) * this.size, (Math.random() - 0.5) * this.size);
                        ctx.lineTo((Math.random() - 0.5) * this.size, (Math.random() - 0.5) * this.size);
                        ctx.stroke();
                    }
                    ctx.globalAlpha = 1;
                }
                
                ctx.restore();
            }
        }
        
        // È´òÂìÅË≥™È≠ö„Ç¢„Ç§„ÉÜ„É†„ÇØ„É©„Çπ
        class YarnFish {
            constructor(x, y) {
                this.x = x;
                this.y = y;
                this.size = 18 + Math.random() * 8;
                this.bobOffset = Math.random() * Math.PI * 2;
                this.sparkleTimer = Math.random() * 100;
                this.color = this.generateFishColor();
                this.yarnTexture = this.generateYarnTexture();
                this.swimDirection = Math.random() * Math.PI * 2;
                this.swimSpeed = 0.3 + Math.random() * 0.5;
                this.glowIntensity = 0.5 + Math.random() * 0.5;
            }
            
            generateFishColor() {
                const fishColors = [
                    '#FFB6C1', '#FFA07A', '#F0E68C', '#98FB98',
                    '#87CEEB', '#DDA0DD', '#F5DEB3', '#FFE4E1'
                ];
                return fishColors[Math.floor(Math.random() * fishColors.length)];
            }
            
            generateYarnTexture() {
                return {
                    pattern: Math.floor(Math.random() * 4),
                    density: 0.3 + Math.random() * 0.4,
                    shine: Math.random() * 0.7 + 0.3
                };
            }
            
            update() {
                // Ëá™ÁÑ∂„Å™Ê≥≥„Åé
                this.x += Math.cos(this.swimDirection) * this.swimSpeed;
                this.y += Math.sin(this.swimDirection) * this.swimSpeed * 0.5;
                
                // ÊñπÂêëËª¢Êèõ
                if (Math.random() < 0.02) {
                    this.swimDirection += (Math.random() - 0.5) * 0.5;
                }
                
                // Â¢ÉÁïå„Åß„Éê„Ç¶„É≥„Çπ
                if (this.x < this.size || this.x > canvas.width - this.size) {
                    this.swimDirection = Math.PI - this.swimDirection;
                }
                if (this.y < this.size || this.y > canvas.height - this.size) {
                    this.swimDirection = -this.swimDirection;
                }
                
                // Â¢ÉÁïåÂÜÖ„Å´‰øùÊåÅ
                this.x = Math.max(this.size, Math.min(canvas.width - this.size, this.x));
                this.y = Math.max(this.size, Math.min(canvas.height - this.size, this.y));
                
                this.sparkleTimer++;
                if (this.sparkleTimer > 80) {
                    this.sparkleTimer = 0;
                    this.createSparkle();
                }
            }
            
            createSparkle() {
                gameState.particles.push({
                    x: this.x + (Math.random() - 0.5) * 25,
                    y: this.y + (Math.random() - 0.5) * 25,
                    vx: (Math.random() - 0.5) * 2,
                    vy: -0.5 - Math.random() * 1,
                    life: 60,
                    maxLife: 60,
                    color: '#87CEEB',
                    size: 2 + Math.random() * 3,
                    type: 'sparkle'
                });
            }
            
            draw() {
                ctx.save();
                ctx.translate(this.x, this.y + Math.sin((gameState.time + this.bobOffset) * 0.08) * 4);
                
                // „Ç∞„É≠„ÉºÂäπÊûú
                ctx.shadowColor = this.color;
                ctx.shadowBlur = 8 * this.glowIntensity;
                
                // È≠ö„ÅÆÂΩ±
                ctx.shadowColor = 'rgba(139, 69, 19, 0.3)';
                ctx.shadowBlur = 4;
                ctx.fillStyle = 'rgba(139, 69, 19, 0.2)';
                ctx.beginPath();
                ctx.ellipse(2, 12, this.size * 0.8, this.size * 0.4, 0, 0, Math.PI * 2);
                ctx.fill();
                
                ctx.shadowBlur = 0;
                
                // È≠öÊú¨‰ΩìÔºàÊØõÁ≥∏È¢®Ôºâ
                ctx.fillStyle = this.color;
                ctx.beginPath();
                ctx.ellipse(0, 0, this.size, this.size * 0.75, 0, 0, Math.PI * 2);
                ctx.fill();
                
                // ÊØõÁ≥∏„ÅÆÁ∏´„ÅÑÁõÆ
                ctx.strokeStyle = this.adjustBrightness(this.color, -0.3);
                ctx.lineWidth = 1;
                ctx.lineCap = 'round';
                for (let i = 0; i < 4; i++) {
                    ctx.beginPath();
                    ctx.moveTo(-this.size * 0.6 + i * (this.size * 0.3), -2);
                    ctx.lineTo(-this.size * 0.6 + i * (this.size * 0.3), 2);
                    ctx.stroke();
                }
                
                // Â∞ªÂ∞æÔºàÊØõÁ≥∏È¢®Ôºâ
                ctx.fillStyle = this.adjustBrightness(this.color, -0.1);
                ctx.beginPath();
                ctx.moveTo(this.size, 0);
                ctx.lineTo(this.size + 12, -8);
                ctx.lineTo(this.size + 12, 8);
                ctx.closePath();
                ctx.fill();
                
                // ÁõÆ
                ctx.fillStyle = '#FFFFFF';
                ctx.beginPath();
                ctx.arc(-this.size * 0.4, -4, 4, 0, Math.PI * 2);
                ctx.fill();
                
                ctx.fillStyle = '#2C3E50';
                ctx.beginPath();
                ctx.arc(-this.size * 0.4, -4, 2, 0, Math.PI * 2);
                ctx.fill();
                
                // „Éè„Ç§„É©„Ç§„Éà
                ctx.fillStyle = this.adjustBrightness(this.color, 0.4);
                ctx.globalAlpha = 0.7;
                ctx.beginPath();
                ctx.ellipse(-this.size * 0.3, -this.size * 0.2, this.size * 0.3, this.size * 0.2, 0, 0, Math.PI * 2);
                ctx.fill();
                ctx.globalAlpha = 1;
                
                ctx.restore();
            }
            
            adjustBrightness(color, amount) {
                const num = parseInt(color.replace("#",""), 16);
                const amt = Math.round(2.55 * amount * 100);
                const R = (num >> 16) + amt;
                const G = (num >> 8 & 0x00FF) + amt;
                const B = (num & 0x0000FF) + amt;
                return "#" + (0x1000000 + (R < 255 ? R < 1 ? 0 : R : 255) * 0x10000 +
                    (G < 255 ? G < 1 ? 0 : G : 255) * 0x100 +
                    (B < 255 ? B < 1 ? 0 : B : 255)).toString(16).slice(1);
            }
        }
        
        // ÊØõÁ≥∏Áéâ„Ç¢„Ç§„ÉÜ„É†„ÇØ„É©„Çπ
        class YarnBall {
            constructor(x, y) {
                this.x = x;
                this.y = y;
                this.size = 20 + Math.random() * 10;
                this.bobOffset = Math.random() * Math.PI * 2;
                this.color = this.generateYarnColor();
                this.rotationSpeed = 0.02 + Math.random() * 0.03;
                this.rotation = 0;
                this.glowPulse = Math.random() * Math.PI * 2;
            }
            
            generateYarnColor() {
                const yarnColors = [
                    '#FFD700', '#FF69B4', '#32CD32', '#FF6347',
                    '#9370DB', '#20B2AA', '#FF1493', '#00CED1'
                ];
                return yarnColors[Math.floor(Math.random() * yarnColors.length)];
            }
            
            update() {
                this.rotation += this.rotationSpeed;
                this.glowPulse += 0.05;
            }
            
            draw() {
                ctx.save();
                ctx.translate(this.x, this.y + Math.sin((gameState.time + this.bobOffset) * 0.06) * 5);
                ctx.rotate(this.rotation);
                
                // „Ç∞„É≠„ÉºÂäπÊûú
                const glowIntensity = 0.5 + Math.sin(this.glowPulse) * 0.3;
                ctx.shadowColor = this.color;
                ctx.shadowBlur = 12 * glowIntensity;
                
                // ÊØõÁ≥∏Áéâ„ÅÆÂΩ±
                ctx.shadowColor = 'rgba(139, 69, 19, 0.3)';
                ctx.shadowBlur = 6;
                ctx.fillStyle = 'rgba(139, 69, 19, 0.2)';
                ctx.beginPath();
                ctx.ellipse(3, 15, this.size * 0.9, this.size * 0.5, 0, 0, Math.PI * 2);
                ctx.fill();
                
                ctx.shadowBlur = 0;
                
                // ÊØõÁ≥∏ÁéâÊú¨‰Ωì
                ctx.fillStyle = this.color;
                ctx.beginPath();
                ctx.arc(0, 0, this.size, 0, Math.PI * 2);
                ctx.fill();
                
                // ÊØõÁ≥∏„ÅÆÂ∑ª„ÅçÊ®°Êßò
                ctx.strokeStyle = this.adjustBrightness(this.color, -0.2);
                ctx.lineWidth = 2;
                ctx.lineCap = 'round';
                
                for (let i = 0; i < 8; i++) {
                    const angle = (i / 8) * Math.PI * 2;
                    const radius = this.size * 0.7;
                    ctx.beginPath();
                    ctx.arc(0, 0, radius, angle, angle + Math.PI * 0.3);
                    ctx.stroke();
                }
                
                // „Éè„Ç§„É©„Ç§„Éà
                ctx.fillStyle = this.adjustBrightness(this.color, 0.4);
                ctx.globalAlpha = 0.6;
                ctx.beginPath();
                ctx.ellipse(-this.size * 0.3, -this.size * 0.3, this.size * 0.4, this.size * 0.3, 0, 0, Math.PI * 2);
                ctx.fill();
                ctx.globalAlpha = 1;
                
                // ÊØõÁ≥∏„ÅÆÁ´Ø
                ctx.strokeStyle = this.adjustBrightness(this.color, -0.1);
                ctx.lineWidth = 3;
                ctx.beginPath();
                ctx.moveTo(this.size * 0.8, 0);
                ctx.lineTo(this.size * 1.2, -this.size * 0.3);
                ctx.stroke();
                
                ctx.restore();
            }
            
            adjustBrightness(color, amount) {
                const num = parseInt(color.replace("#",""), 16);
                const amt = Math.round(2.55 * amount * 100);
                const R = (num >> 16) + amt;
                const G = (num >> 8 & 0x00FF) + amt;
                const B = (num & 0x0000FF) + amt;
                return "#" + (0x1000000 + (R < 255 ? R < 1 ? 0 : R : 255) * 0x10000 +
                    (G < 255 ? G < 1 ? 0 : G : 255) * 0x100 +
                    (B < 255 ? B < 1 ? 0 : B : 255)).toString(16).slice(1);
            }
        }
        
        // È´òÂ∫¶„Å™„Éë„Éº„ÉÜ„Ç£„ÇØ„É´„Ç∑„Çπ„ÉÜ„É†
        function updateParticles() {
            for (let i = gameState.particles.length - 1; i >= 0; i--) {
                let p = gameState.particles[i];
                p.x += p.vx;
                p.y += p.vy;
                p.life--;
                
                // ÈáçÂäõÂäπÊûú
                if (p.type !== 'sparkle') {
                    p.vy += 0.05;
                }
                
                // Á©∫Ê∞óÊäµÊäó
                p.vx *= 0.99;
                p.vy *= 0.99;
                
                if (p.life <= 0) {
                    gameState.particles.splice(i, 1);
                } else {
                    ctx.save();
                    
                    const alpha = p.life / p.maxLife;
                    ctx.globalAlpha = alpha;
                    
                    if (p.type === 'yarn') {
                        // ÊØõÁ≥∏„Éë„Éº„ÉÜ„Ç£„ÇØ„É´
                        ctx.fillStyle = p.color;
                        ctx.beginPath();
                        ctx.ellipse(p.x, p.y, p.size, p.size * 0.6, gameState.time * 0.1, 0, Math.PI * 2);
                        ctx.fill();
                        
                        // ÊØõÁ≥∏„ÅÆÁπäÁ∂≠
                        ctx.strokeStyle = p.color;
                        ctx.lineWidth = 1;
                        for (let j = 0; j < 3; j++) {
                            ctx.beginPath();
                            ctx.moveTo(p.x + (Math.random() - 0.5) * p.size, p.y);
                            ctx.lineTo(p.x + (Math.random() - 0.5) * p.size, p.y + 2);
                            ctx.stroke();
                        }
                    } else if (p.type === 'special') {
                        // ÁâπÂà•„Éë„Éº„ÉÜ„Ç£„ÇØ„É´
                        ctx.shadowColor = p.color;
                        ctx.shadowBlur = 8;
                        ctx.fillStyle = p.color;
                        ctx.beginPath();
                        ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
                        ctx.fill();
                        ctx.shadowBlur = 0;
                    } else {
                        // Âü∫Êú¨„Éë„Éº„ÉÜ„Ç£„ÇØ„É´
                        ctx.fillStyle = p.color;
                        ctx.beginPath();
                        ctx.arc(p.x, p.y, p.size || 3, 0, Math.PI * 2);
                        ctx.fill();
                    }
                    
                    ctx.restore();
                }
            }
        }
        
        // „Ç¢„Ç§„ÉÜ„É†ÁîüÊàê„Ç∑„Çπ„ÉÜ„É†
        function spawnItems() {
            // È≠öÁîüÊàê
            if (Math.random() < 0.025 && gameState.fishItems.length < 12) {
                gameState.fishItems.push(new YarnFish(
                    Math.random() * (canvas.width - 100) + 50,
                    Math.random() * (canvas.height - 100) + 50
                ));
            }
            
            // ÊØõÁ≥∏ÁéâÁîüÊàêÔºà„É¨„Ç¢Ôºâ
            if (Math.random() < 0.008 && gameState.yarnItems.length < 6) {
                gameState.yarnItems.push(new YarnBall(
                    Math.random() * (canvas.width - 100) + 50,
                    Math.random() * (canvas.height - 100) + 50
                ));
            }
        }
        
        // „Ç≤„Éº„É†Ê©üËÉΩ
        function addPenguin() {
            if (gameState.fish >= 10 && gameState.penguins.length < 15) {
                gameState.fish -= 10;
                gameState.penguins.push(new IntelligentPenguin(
                    Math.random() * (canvas.width - 100) + 50,
                    Math.random() * (canvas.height - 100) + 50
                ));
                updateUI();
                createPurchaseEffect();
            }
        }
        
        function upgradeFactory() {
            const cost = 50 * gameState.factoryLevel;
            if (gameState.fish >= cost) {
                gameState.fish -= cost;
                gameState.factoryLevel++;
                gameState.mood += 10;
                updateUI();
                createUpgradeEffect();
            }
        }
        
        function activateTurboMode() {
            if (gameState.fish >= 100 && !gameState.turboMode) {
                gameState.fish -= 100;
                gameState.turboMode = true;
                gameState.turboTimer = 600; // 10ÁßíÈñì
                updateUI();
                createTurboEffect();
            }
        }
        
        function buyDecoration() {
            if (gameState.fish >= 25) {
                gameState.fish -= 25;
                gameState.mood += 5;
                addDecoration();
                updateUI();
                createDecorationEffect();
            }
        }
        
        function addDecoration() {
            const decorations = ['üå∏', 'üå∫', 'üéÄ', '‚≠ê', 'üåà', 'ü¶ã', 'üåô', '‚òòÔ∏è'];
            gameState.decorations.push({
                x: Math.random() * canvas.width,
                y: Math.random() * canvas.height,
                emoji: decorations[Math.floor(Math.random() * decorations.length)],
                size: 20 + Math.random() * 15,
                rotation: Math.random() * Math.PI * 2,
                rotationSpeed: (Math.random() - 0.5) * 0.02
            });
        }
        
        function createPurchaseEffect() {
            for (let i = 0; i < 20; i++) {
                gameState.particles.push({
                    x: canvas.width - 100,
                    y: canvas.height - 100,
                    vx: (Math.random() - 0.5) * 8,
                    vy: -Math.random() * 6 - 2,
                    life: 100,
                    maxLife: 100,
                    color: `hsl(${Math.random() * 60 + 300}, 80%, 70%)`,
                    size: 4 + Math.random() * 6,
                    type: 'special'
                });
            }
        }
        
        function createUpgradeEffect() {
            for (let i = 0; i < 30; i++) {
                gameState.particles.push({
                    x: canvas.width / 2,
                    y: canvas.height / 2,
                    vx: (Math.random() - 0.5) * 10,
                    vy: -Math.random() * 8 - 3,
                    life: 120,
                    maxLife: 120,
                    color: `hsl(${Math.random() * 60 + 45}, 90%, 60%)`,
                    size: 5 + Math.random() * 8,
                    type: 'special'
                });
            }
        }
        
        function createTurboEffect() {
            for (let i = 0; i < 50; i++) {
                gameState.particles.push({
                    x: Math.random() * canvas.width,
                    y: Math.random() * canvas.height,
                    vx: (Math.random() - 0.5) * 12,
                    vy: -Math.random() * 10 - 4,
                    life: 150,
                    maxLife: 150,
                    color: `hsl(${Math.random() * 360}, 90%, 70%)`,
                    size: 6 + Math.random() * 10,
                    type: 'special'
                });
            }
        }
        
        function createDecorationEffect() {
            for (let i = 0; i < 15; i++) {
                gameState.particles.push({
                    x: Math.random() * canvas.width,
                    y: Math.random() * canvas.height,
                    vx: (Math.random() - 0.5) * 6,
                    vy: -Math.random() * 4 - 1,
                    life: 80,
                    maxLife: 80,
                    color: `hsl(${Math.random() * 360}, 70%, 80%)`,
                    size: 3 + Math.random() * 5,
                    type: 'sparkle'
                });
            }
        }
        
        // UIÊõ¥Êñ∞
        function updateUI() {
            document.getElementById('fishCount').textContent = gameState.fish;
            document.getElementById('score').textContent = gameState.score;
            document.getElementById('penguinCount').textContent = gameState.penguins.length;
            document.getElementById('yarnCount').textContent = gameState.yarnBalls;
            
            // „É†„Éº„Éâ„Éê„ÉºÊõ¥Êñ∞
            const moodFill = document.getElementById('moodFill');
            const clampedMood = Math.max(0, Math.min(100, gameState.mood));
            moodFill.style.width = clampedMood + '%';
            
            // „Éú„Çø„É≥„ÅÆÊúâÂäπ/ÁÑ°ÂäπÁä∂ÊÖã
            const buttons = document.querySelectorAll('.yarn-button');
            buttons[0].disabled = gameState.fish < 10; // „Éö„É≥„ÇÆ„É≥ËøΩÂä†
            buttons[1].disabled = gameState.fish < 50 * gameState.factoryLevel; // „Ç¢„ÉÉ„Éó„Ç∞„É¨„Éº„Éâ
            buttons[2].disabled = gameState.fish < 100 || gameState.turboMode; // „Çø„Éº„Éú
            buttons[3].disabled = gameState.fish < 25; // „Éá„Ç≥„É¨„Éº„Ç∑„Éß„É≥
        }
        
        // ËÉåÊôØÊèèÁîªÔºàÊØõÁ≥∏È¢®Ôºâ
        function drawBackground() {
            // Âü∫Êú¨ËÉåÊôØ
            const gradient = ctx.createLinearGradient(0, 0, canvas.width, canvas.height);
            gradient.addColorStop(0, '#F0F8FF');
            gradient.addColorStop(0.5, '#E6F3FF');
            gradient.addColorStop(1, '#DDE9F0');
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // ÊØõÁ≥∏„ÅÆÁπî„ÇäÊ®°Êßò
            ctx.strokeStyle = 'rgba(139, 69, 19, 0.1)';
            ctx.lineWidth = 1;
            
            // Ê®™„ÅÆÁπî„Çä
            for (let i = 0; i < canvas.height; i += 20) {
                ctx.beginPath();
                ctx.moveTo(0, i + Math.sin(gameState.time * 0.01 + i * 0.1) * 2);
                ctx.lineTo(canvas.width, i + Math.sin(gameState.time * 0.01 + i * 0.1) * 2);
                ctx.stroke();
            }
            
            // Á∏¶„ÅÆÁπî„Çä
            for (let i = 0; i < canvas.width; i += 20) {
                ctx.beginPath();
                ctx.moveTo(i + Math.sin(gameState.time * 0.008 + i * 0.1) * 2, 0);
                ctx.lineTo(i + Math.sin(gameState.time * 0.008 + i * 0.1) * 2, canvas.height);
                ctx.stroke();
            }
            
            // „Éá„Ç≥„É¨„Éº„Ç∑„Éß„É≥ÊèèÁîª
            for (let deco of gameState.decorations) {
                ctx.save();
                ctx.translate(deco.x, deco.y);
                ctx.rotate(deco.rotation);
                ctx.font = deco.size + 'px Arial';
                ctx.textAlign = 'center';
                ctx.fillText(deco.emoji, 0, 0);
                deco.rotation += deco.rotationSpeed;
                ctx.restore();
            }
        }
        
        // Èü≥ÈüøÂäπÊûúÔºàÁ∞°ÊòìÁâà„Éª„Ç®„É©„ÉºÂØæÁ≠ñÔºâ
        let audioContext = null;
        
        function initAudioContext() {
            if (!audioContext && gameState.soundEnabled) {
                try {
                    audioContext = new (window.AudioContext || window.webkitAudioContext)();
                } catch (e) {
                    console.log('Audio not supported');
                    gameState.soundEnabled = false;
                }
            }
        }
        
        function playSound(frequency, duration) {
            if (!gameState.soundEnabled) return;
            
            try {
                initAudioContext();
                if (!audioContext) return;
                
                if (audioContext.state === 'suspended') {
                    audioContext.resume();
                }
                
                const oscillator = audioContext.createOscillator();
                const gainNode = audioContext.createGain();
                
                oscillator.connect(gainNode);
                gainNode.connect(audioContext.destination);
                
                oscillator.frequency.setValueAtTime(frequency, audioContext.currentTime);
                gainNode.gain.setValueAtTime(0.1, audioContext.currentTime);
                gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + duration);
                
                oscillator.start(audioContext.currentTime);
                oscillator.stop(audioContext.currentTime + duration);
            } catch (e) {
                console.log('Sound error:', e);
            }
        }
        
        // „É¶„Éº„ÉÜ„Ç£„É™„ÉÜ„Ç£Èñ¢Êï∞
        function toggleSound() {
            gameState.soundEnabled = !gameState.soundEnabled;
            const button = document.querySelector('.settings-panel .mini-button');
            button.textContent = gameState.soundEnabled ? 'üîä' : 'üîá';
        }
        
        function saveGame() {
            const saveData = {
                fish: gameState.fish,
                score: gameState.score,
                yarnBalls: gameState.yarnBalls,
                factoryLevel: gameState.factoryLevel,
                mood: gameState.mood,
                penguinCount: gameState.penguins.length,
                decorationCount: gameState.decorations.length,
                savedAt: Date.now()
            };
            localStorage.setItem('yarnPenguinFactory', JSON.stringify(saveData));
            
            // ‰øùÂ≠ò„Ç®„Éï„Çß„ÇØ„Éà
            createPurchaseEffect();
            playSound(523.25, 0.2); // C5
        }
        
        function loadGame() {
            const saveData = localStorage.getItem('yarnPenguinFactory');
            if (saveData) {
                const data = JSON.parse(saveData);
                gameState.fish = data.fish || 0;
                gameState.score = data.score || 0;
                gameState.yarnBalls = data.yarnBalls || 0;
                gameState.factoryLevel = data.factoryLevel || 1;
                gameState.mood = data.mood || 70;
                
                // „Éö„É≥„ÇÆ„É≥„ÇíÂæ©ÂÖÉ
                for (let i = 0; i < (data.penguinCount || 3); i++) {
                    gameState.penguins.push(new IntelligentPenguin(
                        Math.random() * (canvas.width - 100) + 50,
                        Math.random() * (canvas.height - 100) + 50
                    ));
                }
                
                // „Éá„Ç≥„É¨„Éº„Ç∑„Éß„É≥„ÇíÂæ©ÂÖÉ
                for (let i = 0; i < (data.decorationCount || 0); i++) {
                    addDecoration();
                }
            }
        }
        
        function showStats() {
            const stats = `
üéØ Áµ±Ë®àÊÉÖÂ†± üéØ
‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ
üêü Á∑èÈ≠öÊï∞: ${gameState.fish}
‚≠ê „Çπ„Ç≥„Ç¢: ${gameState.score}
üß∂ ÊØõÁ≥∏Áéâ: ${gameState.yarnBalls}
üêß „Éö„É≥„ÇÆ„É≥Êï∞: ${gameState.penguins.length}
üè≠ Â∑•Â†¥„É¨„Éô„É´: ${gameState.factoryLevel}
üåü „É†„Éº„Éâ: ${Math.round(gameState.mood)}%
üé® „Éá„Ç≥„É¨„Éº„Ç∑„Éß„É≥: ${gameState.decorations.length}
‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ
            `;
            alert(stats);
        }
        
        // „É°„Ç§„É≥„Ç≤„Éº„É†„É´„Éº„Éó
        function gameLoop() {
            gameState.time++;
            
            // „Çø„Éº„Éú„É¢„Éº„ÉâÁÆ°ÁêÜ
            if (gameState.turboMode) {
                gameState.turboTimer--;
                if (gameState.turboTimer <= 0) {
                    gameState.turboMode = false;
                }
            }
            
            // „É†„Éº„ÉâËá™ÁÑ∂Â§âÂåñ
            gameState.mood += (Math.random() - 0.5) * 0.1;
            gameState.mood = Math.max(0, Math.min(100, gameState.mood));
            
            // ËÉåÊôØÊèèÁîª
            drawBackground();
            
            // „Ç¢„Ç§„ÉÜ„É†ÁîüÊàê
            spawnItems();
            
            // È≠öÊõ¥Êñ∞„ÉªÊèèÁîª
            for (let fish of gameState.fishItems) {
                fish.update();
                fish.draw();
            }
            
            // ÊØõÁ≥∏ÁéâÊõ¥Êñ∞„ÉªÊèèÁîª
            for (let yarn of gameState.yarnItems) {
                yarn.update();
                yarn.draw();
            }
            
            // „Éö„É≥„ÇÆ„É≥Êõ¥Êñ∞„ÉªÊèèÁîª
            for (let penguin of gameState.penguins) {
                penguin.update();
                penguin.draw();
            }
            
            // „Éë„Éº„ÉÜ„Ç£„ÇØ„É´Êõ¥Êñ∞
            updateParticles();
            
            // UIÊõ¥Êñ∞
            updateUI();
            
            requestAnimationFrame(gameLoop);
        }
        
        // ÂàùÊúüÂåñ
        function init() {
            // „Çª„Éº„Éñ„Éá„Éº„ÇøË™≠„ÅøËæº„Åø
            loadGame();
            
            // ÂàùÊúü„Éö„É≥„ÇÆ„É≥„ÅåË∂≥„Çä„Å™„ÅÑÂ†¥Âêà„ÅØËøΩÂä†
            while (gameState.penguins.length < 3) {
                gameState.penguins.push(new IntelligentPenguin(
                    100 + gameState.penguins.length * 150,
                    300 + Math.random() * 100
                ));
            }
            
            // ÂàùÊúü„Ç¢„Ç§„ÉÜ„É†ÈÖçÁΩÆ
            for (let i = 0; i < 4; i++) {
                gameState.fishItems.push(new YarnFish(
                    Math.random() * (canvas.width - 100) + 50,
                    Math.random() * (canvas.height - 100) + 50
                ));
            }
            
            for (let i = 0; i < 2; i++) {
                gameState.yarnItems.push(new YarnBall(
                    Math.random() * (canvas.width - 100) + 50,
                    Math.random() * (canvas.height - 100) + 50
                ));
            }
            
            updateUI();
            gameLoop();
            
            // ÊµÆÈÅäÊØõÁ≥∏Áéâ„Éá„Ç≥„É¨„Éº„Ç∑„Éß„É≥
            createFloatingYarns();
        }
        
        function createFloatingYarns() {
            for (let i = 0; i < 5; i++) {
                const yarn = document.createElement('div');
                yarn.className = 'floating-yarn';
                yarn.textContent = 'üß∂';
                yarn.style.left = Math.random() * window.innerWidth + 'px';
                yarn.style.top = Math.random() * window.innerHeight + 'px';
                yarn.style.animationDelay = Math.random() * 4 + 's';
                document.body.appendChild(yarn);
            }
        }
        
        // „Ç§„Éô„É≥„Éà„É™„Çπ„Éä„Éº
        canvas.addEventListener('click', (e) => {
            // „É¶„Éº„Ç∂„Éº„Ç§„É≥„Çø„É©„ÇØ„Ç∑„Éß„É≥ÊôÇ„Å´„Ç™„Éº„Éá„Ç£„Ç™„Ç≥„É≥„ÉÜ„Ç≠„Çπ„Éà„ÇíÂàùÊúüÂåñ
            initAudioContext();
            
            const rect = canvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;
            
            // È≠öËøΩÂä†
            gameState.fishItems.push(new YarnFish(x, y));
            
            // „ÇØ„É™„ÉÉ„ÇØ„Ç®„Éï„Çß„ÇØ„Éà
            for (let i = 0; i < 8; i++) {
                gameState.particles.push({
                    x: x,
                    y: y,
                    vx: (Math.random() - 0.5) * 6,
                    vy: -Math.random() * 4 - 1,
                    life: 60,
                    maxLife: 60,
                    color: `hsl(${Math.random() * 360}, 70%, 70%)`,
                    size: 3 + Math.random() * 4,
                    type: 'sparkle'
                });
            }
            
            playSound(659.25, 0.1); // E5
        });
        
        // „Çø„ÉÉ„ÉÅ„Éá„Éê„Ç§„ÇπÂØæÂøú
        canvas.addEventListener('touchstart', (e) => {
            e.preventDefault();
            const rect = canvas.getBoundingClientRect();
            const touch = e.touches[0];
            const x = touch.clientX - rect.left;
            const y = touch.clientY - rect.top;
            
            gameState.fishItems.push(new YarnFish(x, y));
        });
        
        // Ëá™Âãï‰øùÂ≠ò
        setInterval(() => {
            saveGame();
        }, 30000); // 30Áßí„Åî„Å®
        
        // „Ç≤„Éº„É†ÈñãÂßã
        init();
    </script>
</body>
</html>
    </script>
</body>
</html>